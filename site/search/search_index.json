{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Global Data Plane","text":"<p>The Global Data Plane is a set of open standards for representing, querying, and transferring tabular data between systems.</p> <p>It consists of three main components:</p> <ul> <li>Simple Data Markup Language (SDML): A standard, JSON-based, human-readable format for describing tabular data and schemas.</li> <li>Simple Data Query Language (SDQL): A JSON-based minimal query language for filtering and selecting data from tables.</li> <li>Simple Data Transfer Protocol (SDTP): An HTTP-based protocol for querying SDML tables over the network using SDQL.</li> </ul> <p>Together, these standards provide a transparent, consistent way to move and work with tabular data\u2014across tools, teams, and environments.</p> <p>This repository contains implementations and tools for all three components.</p>"},{"location":"#design-goals","title":"Design Goals","text":"<p>The GDP is intended to make data publishing and access simple and transparent.</p> <ul> <li>Simplicity: Clarity and ease of use\u2014edit by hand, read by eye.</li> <li>Remote Queries: Query any SDTP server over HTTP with plain REST calls.</li> <li>Easy Conversion: Move data to and from JSON, CSV, pandas, XLS/XLSX, and SQL databases.</li> <li>Streaming Support: Static and streaming/tabular data.</li> <li>Composability: Build, filter, and combine data and queries with a text editor.</li> <li>Extensibility: Add new operators, types, or backends as your needs grow.</li> <li>Transparency: Inspect and understand every data flow\u2014no hidden magic.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! - Please see CONTRIBUTING.md for guidelines on code, documentation, and issues. - All code and documentation changes should include clear explanations and, where possible, test coverage. - Bug reports and feature requests are welcome via GitHub Issues.</p>"},{"location":"#faq","title":"FAQ","text":"<p>Q: Who is this for? A: Developers, data engineers, and anyone who needs to move tabular data simply and reliably between tools or teams.</p> <p>Q: Can I use this with my existing tools and workflows? A: Yes. GDP tools are designed for interoperability. You can convert to/from pandas, SQL, CSV, and other formats.</p> <p>Q: Where Can You Use It? - Locally, in cloud environments, or between organizations\u2014anywhere tabular data needs to be exchanged or queried.</p> <p>Q: What software do I need to run to create an SDML Table? - SDML tables can be created in any text editor</p> <p>Q: What software do I need to run to create an SDQL Filter? - SDQL filters can be created in any text editor</p> <p>Q: What client software do I need to run to query a remote SDTP server? - SDTP doesn't require any client software: any HTTP/HTTPS requests library (e.g., Python <code>requests</code>, the utility <code>curl</code>) can be used.  The package provides a convenience client, but this isn't required.</p> <p>Q: Can SDTP be implemented on a standard HTTP Server? - SDTP is a set of routes that can be implemented by any HTTP Server</p> <p>Q: Where and how are SDML Tables stored? - SDML and SDQL do not imply any implementation.  An SDML Table is an abstract, not concrete, artifact; it is the data equivalent of a software API.  It simply declares that each record is of the lengths and types of the schema, and that it will deliver matching rows in response to an SDQL Query.  In the package, we offer two standard SDML Tables -- a RowTable, where the rows are physically present in the table structure, and a RemoteSDMLTable, where the table is hosted at a remote SDTP Server.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Global Data Plane","text":"<p>We welcome contributions\u2014bug reports, feature requests, documentation improvements, or code.</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Open an Issue: </li> <li>Use GitHub Issues to report bugs, suggest features, or ask questions.</li> <li> <p>Please check if your issue is already open before filing a new one.</p> </li> <li> <p>Discuss Major Changes First: </p> </li> <li>For large features or design changes, open an issue to start a discussion before you begin work.</li> <li> <p>We want to make sure your work fits with the project direction and roadmap.</p> </li> <li> <p>Fork, Branch, and Submit a Pull Request: </p> </li> <li>Fork the repo and create a new branch for your change.</li> <li>Write clear, descriptive commit messages.</li> <li> <p>Submit a pull request with a summary of your changes and reference relevant issues.</p> </li> <li> <p>Code Requirements: </p> </li> <li>Write clean, readable code with comments as needed.</li> <li>Include tests for new functionality or bug fixes where possible.</li> <li> <p>Follow project coding style (see README or existing files for reference).</p> </li> <li> <p>Documentation: </p> </li> <li>Update documentation for any user-facing changes, new features, or configuration options.</li> <li>If your change affects APIs, update or add to the API docs.</li> </ol>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the Contributor Covenant Code of Conduct.</p>"},{"location":"CONTRIBUTING/#questions","title":"Questions?","text":"<p>If you have questions, open an issue or start a discussion on GitHub. We\u2019re happy to help.</p> <p>Thank you for helping make Global Data Plane better!</p>"},{"location":"LICENSE/","title":"License","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2024-2025, The Regents of the University of California (Regents)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"architecture/","title":"Global Data Plane \u2013 Architecture","text":""},{"location":"architecture/#executive-summary","title":"Executive Summary","text":"<p>The Global Data Plane (GDP) architecture prioritizes clarity, portability, and simplicity. Tabular data \u2014 from small files to real-time streams \u2014 is described using SDML (Simple Data Markup Language). Queries use SDQL, an explicit and composable query language. The GDP Server exposes a REST API, designed to avoid embedding business logic or vendor-specific extensions. The architecture is structured so that developers in any language can implement or extend the protocol without hidden requirements or additional complexity.</p>"},{"location":"architecture/#purpose","title":"Purpose","text":"<p>This document describes the core architectural principles and decisions for GDP:</p> <ul> <li>SDML provides a declarative, minimal format for tabular data.</li> <li>GDP Protocol offers a transport mechanism for SDML data and metadata.</li> </ul> <p>GDP is designed to enable durable, explicit tabular data exchange, emphasizing composability over built-in features or automation.</p>"},{"location":"architecture/#design-tenets","title":"Design Tenets","text":"<p>GDP is based on the following principles:</p> <ol> <li> <p>Optimize for the common case; delegate the rare.</p> </li> <li> <p>Direct support for typical scenarios.</p> </li> <li>Advanced or infrequent use cases are implemented externally.</li> <li> <p>Compose platforms; avoid overloading them.</p> </li> <li> <p>Each architectural layer has a narrow scope.</p> </li> <li>Non-essential features are handled outside the core protocol.</li> </ol> <p>This approach draws on systems design traditions emphasizing separation of concerns and minimal core scope.</p>"},{"location":"architecture/#sdml-declarative-contract","title":"SDML: Declarative Contract","text":"<p>SDML provides a contract for describing tabular data. It is not a database, runtime, or inference engine. SDML describes:</p> <ul> <li>Column names and semantic types (e.g., string, number, boolean, date, timestamp).</li> <li>Optional row data (human-readable values).</li> <li>The intended shape and semantics of the table, independent of storage or processing layer.</li> </ul> <p>Note: Schema inference is not supported. SDML schemas are explicitly authored. Automatic inference is delegated to external tools.</p>"},{"location":"architecture/#protocol-minimal-transport-layer","title":"Protocol: Minimal Transport Layer","text":"<p>GDP protocol transmits SDML artifacts and metadata. It does not include:</p> <ul> <li>Remote procedure calls (RPC) or distributed execution.</li> <li>Data syncing or version control.</li> <li>Authentication, federation, or workflow orchestration.</li> </ul> <p>The protocol is a minimal channel for structured data movement, not interpretation.</p>"},{"location":"architecture/#composability","title":"Composability","text":"<p>Design trade-offs always favor composability:</p> <ul> <li>Schema inference and validation are handled externally.</li> <li>User interfaces are implemented via extensions or external applications.</li> <li>AI and LLM integrations occur via wrappers, not as part of the schema or protocol itself.</li> </ul> <p>GDP remains minimal, explicit, and testable. New features are added only when they cannot be composed externally.</p>"},{"location":"architecture/#design-commitments","title":"Design Commitments","text":"<ul> <li>The schema is the authoritative source of truth; it is both human- and machine-readable.</li> <li>All behaviors are explicit and documented; there is no implicit state or effect.</li> <li>The core protocol is minimal; extended features reside outside the core.</li> <li>Documentation is mandatory and should be accessible to both human and programmatic consumers.</li> <li>Clarity and transparency are prioritized above performance optimizations or feature additions.</li> </ul>"},{"location":"architecture/#component-overview","title":"Component Overview","text":""},{"location":"architecture/#scope","title":"Scope","text":"<p>The Global Data Plane consists of three primary components:</p> <ul> <li>SDML: Simple Data Markup Language (declarative schema and table definition)</li> <li>SDQL: Simple Data Query Language (explicit, composable query language for tabular data)</li> <li>SDTP: Simple Data Transfer Protocol (minimal REST protocol for moving SDML artifacts and their metadata between systems)</li> </ul> <p>All three components work together to provide a durable, platform-agnostic layer for tabular data exchange. \u201cGlobal Data Plane\u201d refers to this unified abstraction. SDTP remains the protocol and API layer. SDML and SDQL are the contract and query layers, respectively.</p>"},{"location":"architecture/#component-boundaries","title":"Component Boundaries","text":"<ul> <li>SDML defines data structure, schema, and semantics.</li> <li>SDQL defines how queries are constructed and expressed; it is limited to explicit, composable operations and does not support procedural logic or side effects.</li> <li>SDTP specifies how SDML and SDQL documents are transmitted over HTTP; it exposes endpoints for sending, retrieving, and listing tables and queries.</li> </ul> <p>Each component is developed and versioned independently, but all conform to the architectural principles described above.</p>"},{"location":"architecture/#integration-points","title":"Integration Points","text":"<p>External features \u2014 such as validation, connectors to storage systems, or AI integration \u2014 are composed as plugins or wrappers around the core Global Data Plane APIs. No internal logic is assumed; all non-core capabilities are documented as extensions or example integrations.</p>"},{"location":"architecture/#summary-table","title":"Summary Table","text":"Component Purpose Scope Extensible via SDML Schema &amp; Table definition Declarative, minimal contract Plugins, tools SDQL Query specification Explicit, composable, limited Adapters SDTP Protocol/API for data movement RESTful, minimal, stateless Extensions"},{"location":"overview/","title":"Global Data Plane \u2014 Overview","text":"<p>The Global Data Plane (GDP) is an open standard for describing, transferring, and querying tabular data using a portable JSON format and a REST API.</p> <p>GDP makes it easy to share structured data between tools, teams, and environments\u2014locally or in the cloud\u2014without vendor lock-in or custom scripts.</p>"},{"location":"overview/#components","title":"Components","text":"<ul> <li>Simple Data Markup Language (SDML): Standard JSON-based table format.</li> <li>Simple Data Query Language (SDQL): Lightweight language for filtering/selecting data.</li> <li>Simple Data Transfer Protocol (SDTP): REST API for remote data access and queries.</li> </ul>"},{"location":"overview/#typical-workflow","title":"Typical Workflow","text":"<ol> <li>Describe tables with SDML (JSON).</li> <li>Filter/query data with SDQL.</li> <li>Move/query data via SDTP (REST API).</li> </ol> <p>GDP is intended for data engineers, scientists, and analysts who work across heterogeneous systems.</p>"},{"location":"sdml_reference/","title":"SDML Reference \u2014 Global Data Plane","text":""},{"location":"sdml_reference/#1-what-is-a-global-data-plane-table","title":"1. What Is a Global Data Plane Table?","text":"<p>A Global Data Plane (GDP) Table is a code object that plugs into an SDTP server and responds to SDTP API requests for a dataset. Each GDP Table must conform to a standard contract, regardless of how rows are produced or where the data resides.</p>"},{"location":"sdml_reference/#core-features","title":"Core Features","text":"<p>Every GDP Table must provide:</p> <ul> <li>Schema: List of columns with name and type.</li> <li>Filtered Row Access: Method for returning filtered rows, typically via SDQL queries.</li> <li> <p>Column Access and Statistics: Methods to:</p> </li> <li> <p>Return all values in a column (including duplicates)</p> </li> <li>Return all distinct values in a column</li> <li>Return the minimum and maximum value for a column</li> </ul> <p>This contract enables all SDTP servers to handle standard queries, making GDP Tables interchangeable.</p>"},{"location":"sdml_reference/#python-reference-implementation","title":"Python Reference Implementation","text":"<p>GDP Tables are created by subclassing <code>SDMLTable</code> and implementing required methods:</p> <pre><code>class MyTable(SDMLTable):\n    def all_values(self, column_name):\n        # Return all distinct values in the specified column\n\n    def get_column(self, column_name: str):\n        # Return all values (including duplicates) in the specified column\n\n    def range_spec(self, column_name: str):\n        # Return [min, max] for the specified column\n\n    def _get_filtered_rows_from_filter(self, filter=None):\n        # Return all rows matching the filter (full rows, schema order)\n\n    def to_dictionary(self):\n        # Return the table as a Python dictionary\n\n    def to_json(self):\n        # Return the table as a JSON-serializable object\n</code></pre> <p>Other SDTP servers (in other languages) define equivalent contracts.</p>"},{"location":"sdml_reference/#summary-table-gdp-table-requirements","title":"Summary Table: GDP Table Requirements","text":"Requirement Description Schema Defines columns (name, type) Row access Methods for filtered row access Column stats All/distinct values and min/max for each column Serialization Must support dictionary and JSON export"},{"location":"sdml_reference/#2-sdml-declarative-table-markup","title":"2. SDML: Declarative Table Markup","text":"<p>The Simple Data Markup Language (SDML) is a declarative format that specifies how a GDP Table is instantiated by parameterizing pre-written Table classes with the information they need. SDML files are the configuration files for common Table objects:</p> <ul> <li>The markup declares the table\u2019s schema, type, and the parameters required for that table type.</li> <li>The SDTP server reads this markup, looks up the appropriate Table class (by <code>\"type\"</code>), and uses the markup to construct a live Table instance.</li> </ul>"},{"location":"sdml_reference/#pre-written-table-implementations","title":"Pre-written Table Implementations","text":"<p>Currently, SDML supports parameterization of two built-in Table types:</p>"},{"location":"sdml_reference/#rowtable","title":"RowTable","text":"<p>Used when all rows are explicitly stored in the SDML file itself, loaded into memory at server startup. The required parameter for this table type (see the RowTable section) is the list of rows of the table.</p> <p>Best for datasets that are static or small enough to materialize in memory.</p>"},{"location":"sdml_reference/#remotesdmltable","title":"RemoteSDMLTable","text":"<p>Used when the table data lives on a remote server implementing the SDTP protocol.</p> <p>The SDML file contains all the info needed to query the remote server. These parameters are:</p> <ol> <li>The URL for the remote server</li> <li>The name of the table on the remote server</li> <li>Specification of authentication information, if authentication is required</li> </ol>"},{"location":"sdml_reference/#reference-server-implementation","title":"Reference Server Implementation","text":"<p>The reference server reads the SDML files in the server's tables directory and loads them on startup.</p>"},{"location":"sdml_reference/#3-rowtable","title":"3. RowTable","text":"<p>A RowTable is a table whose rows are explicitly listed in the SDML file itself. This table type is best for datasets that are static or small enough to be fully loaded into memory.</p> <p>Required fields:</p> <ul> <li><code>\"type\"</code>: Must be <code>\"RowTable\"</code>.</li> <li><code>\"schema\"</code>: The schema for the table \u2014 a list of column definitions, each with a <code>name</code> and <code>type</code>.</li> <li><code>\"rows\"</code>: The data itself, as a list of lists (each inner list is a row, matching the schema order).</li> </ul> <p>Example SDML (Nightingale dataset, schema only):</p> <pre><code>{\n  \"type\": \"RowTable\",\n  \"schema\": [\n    {\"name\": \"Month_Number\", \"type\": \"number\"},\n    {\"name\": \"Date\", \"type\": \"date\"},\n    {\"name\": \"Year\", \"type\": \"number\"},\n    {\"name\": \"Month\", \"type\": \"string\"},\n    {\"name\": \"Army\", \"type\": \"number\"},\n    {\"name\": \"Disease\", \"type\": \"number\"},\n    {\"name\": \"Wounds\", \"type\": \"number\"},\n    {\"name\": \"Other\", \"type\": \"number\"},\n    {\"name\": \"Disease.rate\", \"type\": \"number\"},\n    {\"name\": \"Wounds.rate\", \"type\": \"number\"},\n    {\"name\": \"Other.rate\", \"type\": \"number\"}\n  ],\n  \"rows\": [\n    /* Each row is a list matching the schema above, e.g.:\n       [1, \"1854-04-01\", 1854, \"Apr\", 8571, 1, 0, 5, 1.4, 7, 2.1],\n       ...\n    */\n  ]\n}\n</code></pre> <p>Note: JSON does not support comments; the 'rows' comments above are for documentation purposes only.</p> <p>Behavior:</p> <ul> <li>All SDTP queries (row filters, column values, min/max) are performed in memory over this row data.</li> <li>The order of fields in each <code>rows</code> entry must match the order of the <code>schema</code> array.</li> <li>RowTable is not recommended for datasets that cannot fit entirely in memory. For large datasets, use a remote or streaming table type.</li> </ul>"},{"location":"sdml_reference/#4-remotesdmltable","title":"4. RemoteSDMLTable","text":"<p>A RemoteSDMLTable is a table whose data is hosted on a remote SDTP server. All SDTP API requests (row filters, column values, min/max) are proxied to the remote server specified in the SDML file.</p> <p>Required fields:</p> <ul> <li><code>\"type\"</code>: Must be <code>\"RemoteSDMLTable\"</code>.</li> <li><code>\"schema\"</code>: The schema for the table (column definitions).</li> <li><code>\"url\"</code>: The base URL for the remote SDTP server.</li> <li><code>\"name\"</code>: The name of the table on the remote server.</li> <li><code>\"auth\"</code>: (Optional) Object specifying how to retrieve authentication credentials for requests to the remote server.</li> </ul>"},{"location":"sdml_reference/#the-auth-object","title":"The <code>auth</code> Object","text":"<p>The <code>\"auth\"</code> field defines how the SDTP server retrieves an authentication token, if required by the remote server. The <code>auth</code> object must include a <code>\"type\"</code> and one associated parameter:</p> <code>type</code> Other Field Description <code>env</code> <code>env_var</code> Name of the environment variable containing the bearer token. <code>file</code> <code>path</code> Path to a file holding the bearer token (plaintext, no line breaks). <code>token</code> <code>value</code> The token itself (should be used only for private deployments, not for sharing). <p>When authentication is used, all requests to the remote server will include an HTTP header: <code>Authorization: Bearer &lt;token-value&gt;</code>, where <code>&lt;token-value&gt;</code> is retrieved according to the chosen method.</p>"},{"location":"sdml_reference/#example-sdml","title":"Example SDML","text":"<pre><code>{\n  \"type\": \"RemoteSDMLTable\",\n  \"schema\": [\n    {\"name\": \"Year\", \"type\": \"number\"},\n    {\"name\": \"Democratic\", \"type\": \"number\"},\n    {\"name\": \"Republican\", \"type\": \"number\"},\n    {\"name\": \"Other\", \"type\": \"number\"}\n  ],\n  \"url\": \"https://sdtp-data.example.com/api\",\n  \"name\": \"electoral_college\",\n  \"auth\": {\n    \"type\": \"env\",\n    \"env_var\": \"REMOTE_TABLE_TOKEN\"\n  }\n}\n</code></pre>"},{"location":"sdml_reference/#auth-handling-examples","title":"Auth Handling Examples","text":"<p>env: The server will read the value of the environment variable named in <code>env_var</code> and use it as the bearer token.</p> <p>file: The server will read the token value from the specified file path.</p> <p>token: The token is provided directly in the SDML file. This is not recommended.</p> <p>Note: If the auth field is omitted, no Authorization header is sent. Avoid embedding tokens directly (type: token) in SDML files meant for public distribution. Use <code>env</code> or <code>file</code> for secure deployments.</p> <p>Behavior:</p> <ul> <li>All SDTP queries (row filters, column values, min/max) are forwarded to the specified remote table using the credentials, if provided.</li> <li>The server will return errors from the remote SDTP endpoint as-is, including authorization errors.</li> </ul>"},{"location":"sdml_reference/#remotesdmltable-authentication-examples","title":"RemoteSDMLTable Authentication Examples","text":"<p>1. Environment Variable Token (Recommended for most deployments)</p> <pre><code>{\n  \"type\": \"RemoteSDMLTable\",\n  \"schema\": [\n    {\"name\": \"ID\", \"type\": \"string\"},\n    {\"name\": \"Measurement\", \"type\": \"number\"}\n  ],\n  \"url\": \"https://data.example.com/api\",\n  \"name\": \"experiment_results\",\n  \"auth\": {\n    \"type\": \"env\",\n    \"env_var\": \"EXPERIMENT_TOKEN\"\n  }\n}\n</code></pre> <p>The SDTP server reads the value of the EXPERIMENT_TOKEN environment variable and uses it as the bearer token for Authorization.</p> <p>2. File-based Token (Good for containerized or server deployments)</p> <pre><code>{\n  \"type\": \"RemoteSDMLTable\",\n  \"schema\": [\n    {\"name\": \"Sample\", \"type\": \"string\"},\n    {\"name\": \"Result\", \"type\": \"number\"}\n  ],\n  \"url\": \"https://sdtp.partnerlab.org/api\",\n  \"name\": \"lab_data\",\n  \"auth\": {\n    \"type\": \"file\",\n    \"path\": \"/run/secrets/partnerlab_token\"\n  }\n}\n</code></pre> <p>The SDTP server reads the token from the specified file and uses it for Authorization.</p> <p>3. Inline Token (For private/local-only SDML, not recommended for sharing)</p> <pre><code>{\n  \"type\": \"RemoteSDMLTable\",\n  \"schema\": [\n    {\"name\": \"PatientID\", \"type\": \"string\"},\n    {\"name\": \"Score\", \"type\": \"number\"}\n  ],\n  \"url\": \"https://secure.healthnet.example/api\",\n  \"name\": \"test_scores\",\n  \"auth\": {\n    \"type\": \"token\",\n    \"value\": \"abc123XYZ-private-access\"\n  }\n}\n</code></pre> <p>The token value is included directly. Do not use this method for files intended for distribution.</p> <p>4. No Authentication (Public data or test systems)</p> <pre><code>{\n  \"type\": \"RemoteSDMLTable\",\n  \"schema\": [\n    {\"name\": \"Year\", \"type\": \"number\"},\n    {\"name\": \"Population\", \"type\": \"number\"}\n  ],\n  \"url\": \"https://open-data.example/api\",\n  \"name\": \"census\"\n}\n</code></pre> <p>No auth field; requests are sent with no Authorization header.</p> <p>Best Practice: Use <code>\"type\": \"env\"</code> or <code>\"type\": \"file\"</code> for production and shared SDML. Never embed real tokens in SDML intended for public or collaborative use.</p>"},{"location":"sdml_reference/#5-extensions-new-table-types-draft","title":"5. Extensions: New Table Types (Draft)","text":"<p>SDML is designed for extensibility. In the future, we expect new table types to be contributed by both core and third-party developers.</p> <p>Current status:</p> <ul> <li>The extension architecture is under development and subject to change.</li> <li>At present, only <code>RowTable</code> and <code>RemoteSDMLTable</code> are fully supported.</li> </ul>"},{"location":"sdml_reference/#draft-process-for-contributing-new-table-types","title":"Draft Process for Contributing New Table Types","text":"<p>To add a new table type, the following draft workflow will apply:</p> <ol> <li> <p>Define a new Table class</p> </li> <li> <p>Subclass the GDP Table base class (<code>SDMLTable</code> in the Python reference server).</p> </li> <li>Implement all required API methods for schema, row, and column access.</li> <li> <p>Write a Factory class</p> </li> <li> <p>The factory knows how to parse the relevant SDML file/section and instantiate your Table class.</p> </li> <li> <p>Register your Table type</p> </li> <li> <p>Register your Table and Factory with the SDTP server\u2019s table type registry.</p> </li> <li>(Coming soon) Contribute your Table type to the global registry at global-data-plane.github.io to enable ecosystem-wide discovery and reuse.</li> </ol>"},{"location":"sdml_reference/#planned-architecture-for-third-party-contributions","title":"Planned Architecture for Third-Party Contributions","text":"<p>We are actively working on:</p> <ul> <li>A robust naming and versioning scheme for contributed table types (e.g., using <code>repo/type</code> or <code>org/type</code> identifiers).</li> <li>A global registry and review process for contributed Table types to ensure security and interoperability.</li> <li>A plugin/extension mechanism for SDTP servers to discover, install, and serve new Table types with minimal friction.</li> </ul> <p>If you are interested in contributing or have suggestions for the extension mechanism, please contact the GDP project .</p> <p>Note: Until the extension mechanism is finalized, third-party Table types are experimental and may require manual integration with the SDTP server.</p> <p>SDML will continue to evolve to support richer and more flexible data access patterns, while keeping its core focus on clarity and composability.</p>"},{"location":"sdml_reference/#6-contributors-and-community","title":"6. Contributors and Community","text":"<p>SDML and the Global Data Plane project are open to contributions, feedback, and collaboration from the community.</p> <ul> <li>To propose changes, request features, or report issues:   Please open an issue or pull request on the SDTP GitHub repository (URL and instructions will be updated as the global registry comes online).</li> <li>To contribute a new Table type:   Watch for updates to the extension and registry architecture in this specification.   We encourage early discussion of ideas and prototypes \u2014 open an issue or start a conversation on the project forums or chat.</li> <li> <p>To join the discussion:</p> </li> <li> <p>Participate in the Global Data Plane community (GitHub)</p> </li> <li>Share feedback, best practices, and use cases</li> <li>Help review and evolve the SDML and SDTP ecosystem</li> </ul> <p>All contributions\u2014code, documentation, discussion, and testing\u2014are welcome. We believe open standards and collaboration are the foundation for the Global Data Plane.</p> <p>Thank you for helping make SDML and GDP better for everyone!</p>"},{"location":"sdql_reference/","title":"SDQL Reference (Simple Data Query Language)","text":"<p>SDQL (Simple Data Query Language) is a minimal, portable query language for filtering and selecting rows and columns from tabular datasets. SDQL is designed for composability, explicitness, and ease of use with the SDTP protocol and SDML table format. It is not intended as a replacement for SQL; instead, it provides a straightforward and interoperable way to express data filters in JSON.</p> <p>It is rare that a user will want to download or examine an entire SDML Table. \u00a0In fact, in some sense, at-source filtering is the entire point of SDTP, and for some tables, downloading the entire table is impossible. \u00a0SDML Tables are logical, not physical, entities. \u00a0For example, a Solar System simulation takes in the initial positions, velocities, and masses of the planets as initial conditions and reports their positions and velocities at arbitrary times in the future. \u00a0An SDML Table representing the Solar System has a column for each planet's position, velocity, and mass, and a column for time. \u00a0Runs of the simulator are triggered by SDQL queries, which specify the initial conditions and request the values for specific ranges of time. \u00a0But the \"table\" itself is infinite, or large enough that it can be treated as such; only finding rows that match specific time periods makes sense.</p> <p>SDQL is designed to be lightweight and simple. \u00a0When the Structured Query Language (SQL) was designed, it was assumed that no computation outside SQL was done, and as a result, SQL was designed to be a full-featured compute engine. \u00a0SDQL has a different set of design assumptions; it assumes that the query agent is a program, and the results of the SDQL query will be inputs to further computation on the client side. \u00a0As a result, SDQL's sole operation is to return the data of interest to the follow-on computation operation. \u00a0Moreover, much of SQL (for example) is devoted to creating conjoined tables on the fly (this is the principal function of the <code>JOIN</code> operation). \u00a0Since the Global Data Plane's tables are semantic, not physical, entities, this is done server-side and isn't exposed in the query language. The sole function of SDQL is to filter and provide summary information on tables.</p>"},{"location":"sdql_reference/#design-principles","title":"Design Principles","text":"<ul> <li>Explicitness: No implicit conversions or behaviors; filters are explicit and fully described in the query object.</li> <li>Portability: All SDQL filters are described using plain JSON; no language-specific syntax or vendor extensions.</li> <li>Composability: Filters may be nested using logical operators (ALL, ANY, NONE) for complex queries.</li> <li>Minimalism: SDQL exposes only a small set of operators, enabling straightforward implementation and static validation.</li> </ul>"},{"location":"sdql_reference/#sdql-and-sql","title":"SDQL and SQL","text":"<p>SDQL can be intuitively thought of as the <code>WHERE</code> clause of a SQL select statement; and, indeed, any SQL clause can be realized as a specialization of a SDQL operator or by a combination of SDQL operators.  For example, the SQL <code>=</code> operator is the SDQL operator <code>IN_LIST</code> where the <code>values</code> list argument is a single list; e.g. <code>Category = 'Electronics'</code> is realized in SDQL as <code>{\"operator\": \"IN_LIST\", \"column\": \"Category\", \"values\":[\"Electronics\"]}</code>.</p>"},{"location":"sdql_reference/#sdql-filter-object-structure","title":"SDQL Filter Object Structure","text":"<p>SDQL is an intermediate form for queries, designed to support a wide range of surface syntaxes and encoding in POST http request bodies. Each SDQL filter is a JSON object with an <code>operator</code> key and operator-specific arguments.</p>"},{"location":"sdql_reference/#example-membership-in-a-value-list","title":"Example: Membership in a value list","text":"<pre><code>{\n  \"operator\": \"IN_LIST\",\n  \"column\": \"Month\",\n  \"values\": [\"Jan\", \"Feb\", \"Mar\"]\n}\n</code></pre>"},{"location":"sdql_reference/#example-value-a-minimum","title":"Example: Value &gt;= a minimum","text":"<pre><code>{\n  \"operator\": \"GE\",\n  \"column\": \"Disease\",\n  \"value\": 1000\n}\n</code></pre>"},{"location":"sdql_reference/#supported-operators","title":"Supported Operators","text":"<p>SDQL Row queries are designed to filter rows of the table; the result of an SDQL row query is the set of rows which match the condition. \u00a0Effectively, it operates as a simple form of a SQL <code>WHERE</code> clause. \u00a0There are currently nine supported operators:</p> Operator Arguments Purpose SQL Analog IN_LIST column, values Membership in a value list <code>&lt;column&gt; = values[0] OR &lt;column&gt; = values[1]...</code> GE column, value column value &gt;= value <code>&lt;column&gt; &gt;= value</code> LE column, value column value &lt;= value <code>&lt;column&gt; &lt;= value</code> GT column, value column value &gt; value <code>&lt;column&gt; &gt; value</code> LT column, value column value &lt; value <code>&lt;column&gt; &lt; value</code> REGEX_MATCH column, expression Regex match for string columns <code>LIKE</code> ANY arguments (array of filters) Logical OR (any sub-filter matches) <code>OR</code> ALL arguments (array of filters) Logical AND (all sub-filters match) <code>AND</code> NONE arguments (array of filters) Logical NOR (none of the sub-filters match) <code>NOT( OR )</code> (<code>NOT</code> if the <code>arguments</code> parameter is a list of length 1) \u2014 e.g. <code>NOT A</code> or <code>NOT (A OR B ...)</code>"},{"location":"sdql_reference/#logical-composition","title":"Logical Composition","text":"<p>SDQL supports composition using the following logical operators:</p> <ul> <li><code>ALL</code>: All sub-filters must match (logical AND)</li> <li><code>ANY</code>: At least one sub-filter must match (logical OR)</li> <li><code>NONE</code>: No sub-filters must match (logical NOR)</li> </ul>"},{"location":"sdql_reference/#example-months-in-1855-with-less-than-200-deaths-by-wounds","title":"Example: Months in 1855 with less than 200 deaths by wounds","text":"<pre><code>{\n  \"operator\": \"ALL\",\n  \"arguments\": [\n    { \"operator\": \"IN_LIST\", \"column\": \"Year\", \"values\": [1855] },\n    { \"operator\": \"LE\", \"column\": \"Wounds\", \"value\": 200 }\n  ]\n}\n</code></pre>"},{"location":"sdql_reference/#result-format","title":"Result Format","text":"<ul> <li>Row queries (e.g., <code>/get_filtered_rows</code>): Returns a JSON list of dicts (one per row), or list of lists if columns are not named. Actual return format may depend on the SDTP endpoint implementation and query parameters.</li> </ul>"},{"location":"sdql_reference/#example-filters-nightingale-dataset","title":"Example Filters (Nightingale Dataset)","text":""},{"location":"sdql_reference/#get-all-months-where-deaths-by-disease-exceeded-2000","title":"Get all months where deaths by disease exceeded 2000","text":"<pre><code>{\n  \"operator\": \"GT\",\n  \"column\": \"Disease\",\n  \"value\": 2000\n}\n</code></pre>"},{"location":"sdql_reference/#get-months-in-1855-with-less-than-200-deaths-by-wounds","title":"Get months in 1855 with less than 200 deaths by wounds","text":"<pre><code>{\n  \"operator\": \"ALL\",\n  \"arguments\": [\n    { \"operator\": \"IN_LIST\", \"column\": \"Year\", \"values\": [1855] },\n    { \"operator\": \"LT\", \"column\": \"Wounds\", \"value\": 200 }\n  ]\n}\n</code></pre>"},{"location":"sdql_reference/#get-all-rows-where-month-is-jan-feb-or-mar","title":"Get all rows where Month is \"Jan\", \"Feb\", or \"Mar\"","text":"<pre><code>{\n  \"operator\": \"IN_LIST\",\n  \"column\": \"Month\",\n  \"values\": [\"Jan\", \"Feb\", \"Mar\"]\n}\n</code></pre>"},{"location":"sdql_reference/#extensibility-and-implementation","title":"Extensibility and Implementation","text":"<ul> <li>SDQL is designed for extension; new operators may be added for project-specific or backend-specific purposes.</li> <li>Unknown or invalid operators should result in a validation error.</li> <li>All SDQL objects are intended to be static and inspectable; dynamic or computed operators are discouraged in the base protocol.</li> </ul>"},{"location":"sdql_reference/#operator-summary-table","title":"Operator Summary Table","text":"Operator Arguments Purpose IN_LIST column, values Membership in a value list GE column, value Column value &gt;= value LE column, value Column value &lt;= value GT column, value Column value &gt; value LT column, value Column value &lt; value REGEX_MATCH column, expression Regex match for string columns ANY arguments (array of filters) Logical OR (any sub-filter matches) ALL arguments (array of filters) Logical AND (all sub-filters match) NONE arguments (array of filters) Logical NOR (none of the sub-filters match)"},{"location":"sdql_reference/#see-also","title":"See Also","text":"<ul> <li>SDTP Protocol Reference</li> <li>SDML Reference</li> <li>Architecture</li> </ul>"},{"location":"sdtp_client/","title":"SDTP Client","text":""},{"location":"sdtp_client/#sdtpclient-python-client-for-sdtp-table-service","title":"SDTPClient \u2014 Python Client for SDTP Table Service","text":""},{"location":"sdtp_client/#introduction","title":"Introduction","text":"<p>The SDTPClient is a robust, extensible Python library for programmatically accessing, querying, and integrating tabular data from SDTP servers using the Global Data Plane architecture. It is designed for simplicity, composability, and seamless integration with modern security and devops workflows.</p> <p>SDTPClient exposes all core SDTP REST endpoints, handles authentication via web-standard methods, and offers a full suite of helper methods for common tabular data workflows \u2014 including DataFrame integration, query/filter builders, and credential management. It can be used interactively (notebooks, scripts), in production services, or as a backend library for analytics, pipelines, and AI partners.</p>"},{"location":"sdtp_client/#authentication-overview","title":"Authentication Overview","text":"<p>SDTPClient is designed for maximum flexibility and ease of integration.</p> <ul> <li>It builds on standard REST/web authentication: HTTP Bearer tokens, which work with OAuth2, API keys, JWTs, and all modern identity providers.</li> <li>No custom auth logic is required: Any web/REST server running SDTP can use its own existing auth layer \u2014\u00a0and the client will supply tokens, keys, or headers as needed.</li> </ul> <p>Reference Implementation:</p> <ul> <li>Accepts requests without enforcing authentication by default. The deployer is responsible for adding security in production environments.</li> </ul> <p>Credential Handling in the Client:</p> <ul> <li>SDTPClient can accept tokens or headers directly, via environment variables, from secure files, or via a YAML config file.</li> <li>The client never stores, issues, or validates credentials \u2014 it simply attaches them to requests as specified.</li> </ul>"},{"location":"sdtp_client/#supplying-credentials-methods-precedence","title":"Supplying Credentials: Methods &amp; Precedence","text":"<p>SDTPClient supports multiple ways to provide authentication tokens/headers:</p> Method How to Use Example Code Use Case Direct token Pass as <code>credential</code> or <code>auth</code> argument at init or per-call <code>client = SDTPClient(url, credential=\"abc123\")</code> Local, secret manager, notebooks Environment var Set token in env var; client auto-discovers <code>os.environ[\"SDTP_CREDENTIAL_VAR\"] = \"abc123\"</code> Containers, CI/CD, notebooks File path Store token in file; client reads via path/env <code>client = SDTPClient(url, credential_path=\"~/.token\")</code> DevOps, servers, K8s secrets YAML config Map server URLs to credential methods via config (see below) Multi-server, ops, complex setups None No credential; for public/trusted server or for testing <code>client = SDTPClient(url)</code> Public/test endpoints <p>Precedence (highest wins):</p> <ol> <li>Direct/explicit (per-call or client arg)</li> <li>Environment variable (default or custom name)</li> <li>File path</li> <li>YAML config file</li> <li>No credential</li> </ol> <p>If multiple methods are provided, SDTPClient resolves in the above order. Per-request credentials always override the default for that call only.</p>"},{"location":"sdtp_client/#yaml-config-file-credential-discovery","title":"YAML Config File: Credential Discovery","text":"<p>For robust, multi-server environments, SDTPClient supports a YAML config file (default: <code>~/.sdtp_client_config.yaml</code>). This file can specify, for each server URL (or a default fallback):</p> <ul> <li><code>env</code>: Name of the environment variable holding the token</li> <li><code>path</code>: Path to a file with the token</li> <li><code>value</code>: Token value (not recommended for production)</li> </ul> <p>Example:</p> <pre><code>credentials:\n  \"https://sdtp1.example.com\": { env: SDTP_API_TOKEN }\n  \"https://sdtp2.example.com\": { path: ~/.secrets/sdtp2_token }\n  \"default\": { env: SDTP_API_TOKEN }\n</code></pre> <ul> <li>The client uses the credential method for the URL, or <code>default</code> if none matches.</li> <li>Env/file changes are picked up between calls.</li> <li>No secrets are written or updated by the client \u2014 only read.</li> </ul>"},{"location":"sdtp_client/#per-request-credential-overrides","title":"Per-Request Credential Overrides","text":"<p>While SDTPClient supports global (client-level) credentials, credentials can also be overridden for individual requests:</p> <ul> <li>Per-call override:   Any API method that issues an HTTP request (e.g., <code>get_filtered_rows</code>, <code>get_table_schema</code>, etc.) accepts an <code>auth</code> or <code>credential</code> argument to supply a token for that request only.</li> </ul> <pre><code># Uses global client credential (default)\nclient.get_filtered_rows(table=\"nightingale\", filter_spec=fspec)\n\n# Override credential for this call only\nclient.get_filtered_rows(table=\"nightingale\", filter_spec=fspec, credential=\"special_token\")\n</code></pre> <ul> <li>Custom headers:   If an SDTP server expects a custom header (not just a Bearer token), the <code>headers</code> argument can be provided as a dictionary to override or supplement the default headers:</li> </ul> <pre><code>client.get_table_schema(table=\"nightingale\", headers={\"Authorization\": \"Bearer abc123\"})\n</code></pre> <ul> <li>Table-level overrides:   If multiple tables on the same SDTP server require different credentials, separate SDTPClient instances may be used with different default credentials, or per-call overrides may be provided as shown above.</li> </ul>"},{"location":"sdtp_client/#credential-resolution-security-guarantees","title":"Credential Resolution &amp; Security Guarantees","text":"<p>SDTPClient resolves and attaches credentials according to the following precedence:</p> <ol> <li>Per-call credential/header (explicit <code>credential</code> or <code>headers</code> argument)</li> <li>Client default (set at initialization)</li> <li>Config file (YAML, for URL or default)</li> <li>Environment variable (as named in config, or <code>SDTP_API_TOKEN</code>)</li> <li>File path (as named in config)</li> <li> <p>None (no credential attached)</p> </li> <li> <p>No credential storage or modification:   SDTPClient does not write, issue, or modify credentials or config files. All files are read-only; no credential values are persisted or cached in memory.</p> </li> <li>No credential validation:   The client only attaches credentials and reports authentication errors as returned by the server. Credential validation is performed server-side.</li> <li>Inspection:   For debugging, the <code>get_credential_method()</code> helper can be used to check which method would be used for a given server or table. The credential value itself is never exposed.</li> </ol>"},{"location":"sdtp_client/#security-considerations","title":"Security Considerations","text":"<ul> <li>The reference SDTP server implementation does not enforce authentication checks\u2014it accepts all requests. Security is the responsibility of the deployer. SDTP endpoints should not be exposed to untrusted networks without proper gateway or proxy authentication.</li> <li>Best practice:   Always use environment variables, secure file paths, or external credential managers for production deployments.   Credentials should not be stored directly in code, notebooks, or YAML configs intended for distribution.</li> <li>Production environments:   Container secret mounts, K8s secrets, Vault, or other system-native credential solutions are recommended.</li> </ul>"},{"location":"sdtp_client/#sdtpclient-api-reference","title":"SDTPClient API Reference","text":""},{"location":"sdtp_client/#class-sdtpclient","title":"Class: SDTPClient","text":""},{"location":"sdtp_client/#initialization","title":"Initialization","text":"<pre><code>SDTPClient(\n    server_url: str,\n    credential: Union[str, dict] = None,\n    credential_env: str = \"SDTP_CREDENTIAL_VAR\",\n    credential_path: str = \"~/.sdtp_token\"\n)\n</code></pre> <p>Arguments:</p> <ul> <li><code>server_url</code> (<code>str</code>): The base URL of the SDTP server.</li> <li> <p><code>credential</code> (<code>str</code> or <code>dict</code>, optional):</p> </li> <li> <p>If a <code>str</code>, treated as a Bearer token for Authorization header.</p> </li> <li>If a <code>dict</code>, supplied as custom HTTP headers.</li> <li><code>credential_env</code> (<code>str</code>, optional): Name of environment variable holding the token (default: <code>\"SDTP_CREDENTIAL_VAR\"</code>).</li> <li><code>credential_path</code> (<code>str</code>, optional): Path to a file containing the credential (default: <code>~/.sdtp_token</code>).</li> </ul> <p>Resolution precedence: If multiple are supplied, the order is: <code>credential (explicit) &gt; credential_env (env var) &gt; credential_path (file) &gt; no credential</code>.</p>"},{"location":"sdtp_client/#credential-resolution","title":"Credential Resolution","text":"<pre><code>_resolve_credential(\n    credential: Union[str, dict, None] = None,\n    headers: Optional[dict] = None\n) -&gt; dict\n</code></pre> <p>Arguments:</p> <ul> <li> <p><code>credential</code> (<code>str</code>, <code>dict</code>, or <code>None</code>):</p> </li> <li> <p>Per-request override; if provided, takes precedence over client default.</p> </li> <li> <p><code>headers</code> (<code>dict</code>, optional):</p> </li> <li> <p>Per-request header dictionary; if provided, is used directly and overrides all other settings.</p> </li> </ul> <p>Returns:</p> <ul> <li><code>dict</code>: HTTP headers for the request.</li> </ul> <p>Notes:</p> <ul> <li>If <code>headers</code> is provided, it is used as-is (full override).</li> <li>If <code>credential</code> is a dict, it is used as custom headers.</li> <li>If <code>credential</code> is a str, it is sent as a Bearer token.</li> <li>If no credential is found, returns <code>{}</code> (no Authorization).</li> </ul>"},{"location":"sdtp_client/#typical-usage-example","title":"Typical Usage Example","text":"<pre><code># Using direct token\nclient = SDTPClient(\"https://sdtp.example.com\", credential=\"abc123\")\n\n# Using environment variable\nimport os\nos.environ[\"SDTP_CREDENTIAL_VAR\"] = \"abc123\"\nclient = SDTPClient(\"https://sdtp.example.com\")\n\n# Using credential file\nclient = SDTPClient(\"https://sdtp.example.com\", credential_path=\"~/token.txt\")\n\n# No credential (for public/trusted endpoints)\nclient = SDTPClient(\"https://sdtp.example.com\")\n</code></pre> <p>Per-request override:</p> <pre><code>client.get_filtered_rows(\"nightingale\", filter_spec, credential=\"temp-token\")\nclient.get_filtered_rows(\"nightingale\", filter_spec, headers={\"Authorization\": \"Bearer alt-token\"})\n</code></pre>"},{"location":"sdtp_client/#summary-of-core-methods","title":"Summary of Core Methods","text":"Method Purpose/Description <code>get_table_names()</code> Returns a list of available table names <code>get_tables()</code> Returns a list of all tables (as dicts) <code>get_table_schema(table)</code> Returns schema for the specified table <code>get_range_spec(table, column)</code> Returns min/max for the specified column <code>get_all_values(table, column)</code> Returns all distinct values in the column <code>get_column(table, column)</code> Returns all values (with duplicates) in the column <code>get_filtered_rows(table, filter_spec, columns=None, result_format=None, credential=None, headers=None)</code> Returns filtered rows matching the query (list or SDML) <ul> <li>All methods accept optional <code>credential</code> and <code>headers</code> arguments for per-call overrides.</li> <li>Methods return native Python objects corresponding to the REST API response.</li> <li>Errors are raised as exceptions with descriptive messages.</li> </ul>"},{"location":"sdtp_client/#minimal-working-example","title":"Minimal Working Example","text":"<pre><code>from sdtp_client import SDTPClient\n\nclient = SDTPClient(url=\"https://sdtp.example.com\")\ntables = client.get_table_names()\nschema = client.get_table_schema(tables[0])\nrows = client.get_filtered_rows(table=tables[0], filter_spec={\"operator\": \"GT\", \"column\": \"Year\", \"value\": 2020})\n</code></pre>"},{"location":"sdtp_client/#best-practices","title":"Best Practices","text":"<ul> <li>Credential management:   Use environment variables, container secret mounts, or secure file paths for all production secrets. Do not hardcode tokens or store them directly in code, notebooks, or YAML configuration intended for sharing.</li> <li>Authentication enforcement:   The reference SDTP server does not require authentication by default; the deployer must ensure that all public or semi-public deployments are protected by an authentication gateway or proxy.</li> <li>Separation of concerns:   The SDTPClient is responsible for credential discovery and transport only; all validation, rotation, and issuance of credentials is performed by the deployer\u2019s infrastructure.</li> <li>YAML configuration:   For complex deployments, a single YAML config file may define credential sources for multiple servers, with a default fallback. No secrets are written or updated by SDTPClient.</li> <li>Audit and rotate:   Periodically audit credential methods and rotate tokens or keys according to organizational security policies.</li> </ul>"},{"location":"sdtp_client/#error-handling-and-troubleshooting","title":"Error Handling and Troubleshooting","text":"<ul> <li>Missing or invalid credentials:   If a credential is not found or is rejected by the server, SDTPClient raises a descriptive exception. The error message will specify which credential resolution steps were attempted.</li> <li>HTTP errors:   All HTTP 4xx/5xx responses are raised as exceptions with the server\u2019s error message attached.</li> <li>Resolution order debugging:   The <code>get_credential_method()</code> helper can be used to confirm which method (env, file, direct) was used for a given request.</li> <li>Configuration issues:   Failure to read or parse the YAML config, or missing/invalid file paths, will result in an immediate exception with diagnostic details.</li> <li>Recommended response:   The user should confirm that all required environment variables, files, and YAML entries are present and correctly formatted.</li> </ul>"},{"location":"sdtp_client/#yaml-configuration-example","title":"YAML Configuration Example","text":"<p>A typical YAML config (<code>~/.sdtp_client_config.yaml</code>) might look like:</p> <pre><code>credentials:\n  \"https://sdtp1.example.com\": { env: SDTP1_TOKEN }\n  \"https://sdtp2.example.com\": { path: ~/.secrets/sdtp2_token }\n  \"default\": { env: SDTP_TOKEN }\n</code></pre> <ul> <li>For each server URL, a credential source is specified (<code>env</code>, <code>path</code>, or <code>value</code>).</li> <li>A <code>\"default\"</code> entry acts as a fallback.</li> <li>Credentials are only read, never written, by the client.</li> </ul>"},{"location":"sdtp_client/#contact-and-support","title":"Contact and Support","text":"<ul> <li>Repository: Global Data Plane on GitHub</li> <li>Documentation: global-data-plane.github.io</li> <li>Issue tracking: Submit bug reports, feature requests, or questions via GitHub Issues.</li> </ul>"},{"location":"sdtp_client/#summary","title":"Summary","text":"<p>SDTPClient is a minimal, robust, and production-ready Python library for interacting with SDTP servers as part of the Global Data Plane ecosystem. Credential management is flexible, secure, and web-standard; the client is designed to integrate with diverse authentication workflows and is safe for use in interactive, batch, and deployed environments.</p> <p>For more details, see the full GDP documentation set and protocol references.</p>"},{"location":"sdtp_protocol_reference/","title":"SDTP Protocol Reference","text":"<p>The SDTP (Simple Data Transfer Protocol) defines a minimal REST API for exposing, querying, and retrieving tabular data described in SDML format. SDTP is designed for clarity, composability, and compatibility, and provides explicit endpoints for accessing table metadata, schema, and filtered row/column data.</p> <p>Note: SDTP does not provide authentication, security, or advanced search. It is intended to be composed with external tools for authentication, proxying, and orchestration.</p>"},{"location":"sdtp_protocol_reference/#route-index","title":"Route Index","text":"Endpoint Method Description /get_table_names GET Returns a list of available table names /get_tables GET Returns a list of all tables (as dicts) /get_table_schema GET Returns schema for a table /get_range_spec POST Returns min/max values for a column /get_all_values POST Returns all distinct values in column /get_column POST Returns all values (with duplicates) /get_filtered_rows POST Returns filtered rows (list or SDML)"},{"location":"sdtp_protocol_reference/#get_table_names","title":"<code>/get_table_names</code>","text":"<p>Returns a JSON list of available table names (not full URLs).</p> <p>Example response:</p> <pre><code>[\"nightingale\", \"elections\"]\n</code></pre>"},{"location":"sdtp_protocol_reference/#get_tables","title":"<code>/get_tables</code>","text":"<p>Returns a JSON list of all tables, each as a dictionary.</p> <p>Example response:</p> <pre><code>[\n  {\n    \"name\": \"nightingale\",\n    \"schema\": [...],\n    \"description\": \"...\"\n  },\n  ...\n]\n</code></pre>"},{"location":"sdtp_protocol_reference/#get_table_schema","title":"<code>/get_table_schema</code>","text":"<p>Returns the schema for a given table.</p> <p>Request: <code>GET /get_table_schema?table=nightingale</code></p> <p>Returns: An object with a <code>columns</code> key, whose value is a list of dictionaries defining each column (name, type, etc).</p> <p>Example response:</p> <pre><code>{\n  \"columns\": [\n    {\"name\": \"Month\", \"type\": \"string\"},\n    {\"name\": \"Year\", \"type\": \"number\"},\n    ...\n  ]\n}\n</code></pre>"},{"location":"sdtp_protocol_reference/#get_range_spec","title":"<code>/get_range_spec</code>","text":"<p>Returns the minimum and maximum values for a column in a table.</p> <p>Request:</p> <pre><code>{\n  \"table\": \"nightingale\",\n  \"column\": \"Year\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"min\": 1854,\n  \"max\": 1856\n}\n</code></pre> <p>Returns HTTP 4xx error if the column or table is not found.</p>"},{"location":"sdtp_protocol_reference/#get_all_values","title":"<code>/get_all_values</code>","text":"<p>Returns all distinct values for a column.</p> <p>Request:</p> <pre><code>{\n  \"table\": \"nightingale\",\n  \"column\": \"Month\"\n}\n</code></pre> <p>Response:</p> <pre><code>[\"Jan\", \"Feb\", \"Mar\", ...]\n</code></pre>"},{"location":"sdtp_protocol_reference/#get_column","title":"<code>/get_column</code>","text":"<p>Returns all values for a column, including duplicates and in table order.</p> <p>Request:</p> <pre><code>{\n  \"table\": \"nightingale\",\n  \"column\": \"Disease\"\n}\n</code></pre> <p>Response:</p> <pre><code>[150, 200, 180, ...]\n</code></pre>"},{"location":"sdtp_protocol_reference/#get_filtered_rows","title":"<code>/get_filtered_rows</code>","text":"<p>Returns rows matching a filter, either as a list of lists (default), or as a full SDML table (if <code>result_format</code> is set to \"sdml\").</p> <p>Request (list format):</p> <pre><code>{\n  \"table\": \"nightingale\",\n  \"columns\": [\"Month\", \"Disease\"],\n  \"filter_spec\": {\n    \"column\": \"Year\",\n    \"operator\": \"IN_LIST\",\n    \"values\": [1855]\n  }\n}\n</code></pre> <p>Response (list format):</p> <pre><code>[\n  [\"Jan\", 3150],\n  [\"Feb\", 2230],\n  ...\n]\n</code></pre> <p>The response is a list of lists, one per row, with values for the requested columns in order.</p> <p>Request (SDML format):</p> <pre><code>{\n  \"table\": \"nightingale\",\n  \"columns\": [\"Month\", \"Disease\"],\n  \"filter_spec\": {\n    \"column\": \"Year\",\n    \"operator\": \"IN_LIST\",\n    \"values\": [1855]\n  },\n  \"result_format\": \"sdml\"\n}\n</code></pre> <p>Response (SDML format):</p> <pre><code>{\n  \"type\": \"RowTable\",\n  \"schema\": [\n    {\"name\": \"Month\", \"type\": \"string\"},\n    {\"name\": \"Disease\", \"type\": \"number\"}\n  ],\n  \"rows\": [\n    [\"Jan\", 3150],\n    [\"Feb\", 2230],\n    ...\n  ]\n}\n</code></pre>"},{"location":"sdtp_protocol_reference/#error-handling","title":"Error Handling","text":"<p>All endpoints return HTTP 4xx or 5xx on error.</p> <p>Error response example:</p> <pre><code>{\n  \"error\": \"Table 'nightingale' not found\"\n}\n</code></pre>"},{"location":"sdtp_protocol_reference/#protocol-conventions-server-to-server-queries","title":"Protocol Conventions: Server-to-Server Queries","text":"<p>SDTP may be used for server-to-server requests, such as proxying SDTP tables from a remote server or integrating with multi-site data providers.</p> <ul> <li>Standard headers: Server-to-server requests may use HTTP headers for forwarding, proxy, or metadata, but SDTP endpoints themselves do not require or interpret these headers.</li> <li>URL composition: All endpoints accept POST (with JSON body) or GET (with query parameters) as specified.</li> </ul> <p>Example server-to-server request:</p> <pre><code>{\n  \"table\": \"experiment_data\",\n  \"columns\": [\"Sample\", \"Result\"],\n  \"filter_spec\": {\n    \"operator\": \"GT\",\n    \"column\": \"Result\",\n    \"value\": 0.9\n  }\n}\n</code></pre> <p>Example server-to-server response:</p> <pre><code>[\n  [\"Sample1\", 0.92],\n  [\"Sample3\", 1.01]\n]\n</code></pre>"},{"location":"sdtp_protocol_reference/#see-also","title":"See Also","text":"<ul> <li>SDML Reference</li> <li>SDQL Reference</li> <li>Architecture</li> </ul>"},{"location":"api/","title":"Class Docs (auto-generated)","text":"<p>A SDMLTable class and associated utilities.  The SDMLTable class is initialized with the table's schema,  single function,get_rows(), which returns the rows of the table.  To use a  SDMLTable instance, instantiate it with the schema and a get_rows() function. The SDMLTable instance can then be passed to a SDTPServer with a call to galyleo_server_framework.add_table_server, and the server will then be able to serve the tables automatically using the instantiated SDMLTable.</p>"},{"location":"api/#sdtp.sdtp_client.SDTPClient","title":"<code>SDTPClient(url, config_path='~/.sdtp_client_config.yaml', auth=None)</code>","text":"<p>Minimal SDTP Client: Connects to SDTP REST endpoints with robust, flexible authentication.</p>"},{"location":"api/#sdtp.sdtp_client.SDTPClient--credential-discovery-authentication","title":"Credential Discovery &amp; Authentication","text":"<p>SDTPClient uses a YAML config file as a minimal password manager, mapping each SDTP server URL to a credential retrieval method:</p> <ul> <li><code>env</code>: Get the credential from a named environment variable (supports ephemeral tokens from IdP or orchestration).</li> <li><code>path</code>: Read the credential from a file (works with secrets managers or file mounts).</li> <li><code>value</code>: Use the explicit token value (for dev/test only).</li> </ul> <p>The config file is read at instantiation (default: <code>~/.sdtp_client_config.yaml</code>), and may be overridden by the <code>SDTP_CLIENT_CONFIG</code> env var or <code>config_path</code> argument.</p> For each API call <ol> <li>If an explicit <code>auth</code> argument is supplied, it overrides all other methods for that call only.</li> <li>Otherwise, the credential method for the client's server URL is looked up in the config file.</li> <li>If no entry is found for the URL, the 'default' entry (if any) is used.</li> <li>If no credential method is found, no Authorization header is sent (anonymous access).</li> </ol> <p>All credential methods are re-evaluated at each call \u2014 changes to env vars or files are picked up automatically.</p> <p>Power users may also specify <code>headers</code> per method to override or add HTTP headers directly.</p>"},{"location":"api/#sdtp.sdtp_client.SDTPClient--convenience-methods","title":"Convenience Methods","text":"<p>SDTPClient provides high-level helpers to build table schemas, filter specs, and DataFrames, minimizing boilerplate and making SDTP more accessible for data science and ETL workflows.</p> <p>See the user documentation for full config format, method details, and best practices.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Base URL of the SDTP server (e.g., \"http://localhost:5000\")</p> required <code>config_path</code> <code>Optional[str]</code> <p>Optional path to the YAML credential config file (default: \"~/.sdtp_client_config.yaml\").</p> <code>'~/.sdtp_client_config.yaml'</code> <code>auth</code> <code>Optional[AuthMethod]</code> <p>Optional explicit AuthMethod for this client (overrides config).</p> <code>None</code> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def __init__(\n    self,\n    url: str,\n    config_path: Optional[str] = \"~/.sdtp_client_config.yaml\",\n    auth: Optional[AuthMethod] = None\n):\n    \"\"\"\n    Args:\n        url: Base URL of the SDTP server (e.g., \"http://localhost:5000\")\n        config_path: Optional path to the YAML credential config file (default: \"~/.sdtp_client_config.yaml\").\n        auth: Optional explicit AuthMethod for this client (overrides config).\n    \"\"\"\n    self.url = url.rstrip(\"/\")\n    self.credentials = load_config(config_path)\n    self.auth = None\n    if auth:\n        self.auth = auth\n    else:\n        self.auth = _query_credential_method(self.credentials, self.url)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.clear","title":"<code>clear()</code>","text":"<p>Clear the stored credential method for this client. After calling, further calls will use config or explicit per-method auth.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def clear(self):\n  \"\"\"\n  Clear the stored credential method for this client.\n  After calling, further calls will use config or explicit per-method auth.\n  \"\"\"\n  self.auth = None\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.echo_json_post","title":"<code>echo_json_post(payload, auth=None)</code>","text":"<p>POST /_echo_json_post \u2014 Echoes posted JSON (debug/testing only).</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>Payload in JSON form.</p> required <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Auth token or method for this request (overrides all others).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The echoed payload (dict).</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def echo_json_post(\n    self,\n    payload: dict,\n    auth: Optional[Union[str, AuthMethod]] = None,\n) -&gt; dict:\n    \"\"\"\n    POST /_echo_json_post \u2014 Echoes posted JSON (debug/testing only).\n\n    Args:\n        payload: Payload in JSON form.\n        auth: Auth token or method for this request (overrides all others).\n\n    Returns:\n        The echoed payload (dict).\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    headers = {'Accept': 'application/json'}\n    token = self._resolve_effective_token(auth)\n    if token:\n        headers['Authorization'] = f'Bearer {token}'\n    response = requests.post(\n        f\"{self.url}/_echo_json_post\",\n        json=payload,\n        headers=headers\n    )\n    return _process_response(response)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_all_values","title":"<code>get_all_values(table_name, column_name, auth=None)</code>","text":"<p>Returns all distinct values for a column.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Table containing the column.</p> required <code>column_name</code> <code>str</code> <p>Column to get values for.</p> required <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: List of column values.</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_all_values(\n    self,\n    table_name: str,\n    column_name: str,\n    auth: Optional[Union[str, AuthMethod]] = None\n) -&gt; List[Any]:\n    \"\"\"\n    Returns all distinct values for a column.\n\n    Args:\n        table_name: Table containing the column.\n        column_name: Column to get values for.\n        auth: Optional string token or AuthMethod dict for this call.\n\n    Returns:\n        List[Any]: List of column values.\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    return self._execute_column_query('get_all_values', table_name, column_name, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_column","title":"<code>get_column(table_name, column_name, auth=None)</code>","text":"<p>Returns the entire column as a list.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Table containing the column.</p> required <code>column_name</code> <code>str</code> <p>Column to get.</p> required <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: The column as a list.</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_column(\n    self,\n    table_name: str,\n    column_name: str,\n    auth: Optional[Union[str, AuthMethod]] = None\n) -&gt; List[Any]:\n    \"\"\"\n    Returns the entire column as a list.\n\n    Args:\n        table_name: Table containing the column.\n        column_name: Column to get.\n        auth: Optional string token or AuthMethod dict for this call.\n\n    Returns:\n        List[Any]: The column as a list.\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    return self._execute_column_query('get_column', table_name, column_name, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_filtered_rows","title":"<code>get_filtered_rows(table, columns=None, filter=None, result_format=None, auth=None)</code>","text":"<p>POST /get_filtered_rows \u2014 Fetch filtered rows from a table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Name of the table (required).</p> required <code>columns</code> <code>Optional[List[str]]</code> <p>List of columns to return (optional).</p> <code>None</code> <code>filter</code> <code>Optional[Dict[str, Any]]</code> <p>SDTP filter spec (optional).</p> <code>None</code> <code>result_format</code> <code>Optional[str]</code> <p>Output format (optional).</p> <code>None</code> <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Auth token or method for this request (overrides all others).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>List of rows (list of lists), or as specified by result_format.</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_filtered_rows(\n    self,\n    table: str,\n    columns: Optional[List[str]] = None,\n    filter: Optional[Dict[str, Any]] = None,\n    result_format: Optional[str] = None,\n    auth: Optional[Union[str, AuthMethod]] = None,\n) -&gt; Any:\n    \"\"\"\n    POST /get_filtered_rows \u2014 Fetch filtered rows from a table.\n\n    Args:\n        table: Name of the table (required).\n        columns: List of columns to return (optional).\n        filter: SDTP filter spec (optional).\n        result_format: Output format (optional).\n        auth: Auth token or method for this request (overrides all others).\n\n    Returns:\n        List of rows (list of lists), or as specified by result_format.\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    headers = {'Accept': 'application/json'}\n    token = self._resolve_effective_token(auth)\n    if token:\n        headers['Authorization'] = f'Bearer {token}'\n    body: Dict[str, Any] = {\"table\": table}\n    if columns is not None:\n        body[\"columns\"] = columns\n    if filter is not None:\n        body[\"filter\"] = filter\n    if result_format is not None:\n        body[\"result_format\"] = result_format\n\n    response = requests.post(\n        f\"{self.url}/get_filtered_rows\",\n        json=body,\n        headers=headers\n    )\n    return _process_response(response)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_range_spec","title":"<code>get_range_spec(table_name, column_name, auth=None)</code>","text":"<p>Returns [min, max] for a column.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Table containing the column.</p> required <code>column_name</code> <code>str</code> <p>Column to get min/max for.</p> required <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>List[Any]: List of length 2: [min, max]</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_range_spec(\n    self,\n    table_name: str,\n    column_name: str,\n    auth: Optional[Union[str, AuthMethod]] = None\n) -&gt; List[Any]:\n    \"\"\"\n    Returns [min, max] for a column.\n\n    Args:\n        table_name: Table containing the column.\n        column_name: Column to get min/max for.\n        auth: Optional string token or AuthMethod dict for this call.\n\n    Returns:\n        List[Any]: List of length 2: [min, max]\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    return self._execute_column_query('get_range_spec', table_name, column_name, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_table_schema","title":"<code>get_table_schema(table_name, auth=None)</code>","text":"<p>Returns the schema for a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Table to get the schema for.</p> required <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List[Dict[str, str]]: Schema for the table.</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_table_schema(\n    self,\n    table_name: str,\n    auth: Optional[Union[str, AuthMethod]] = None\n) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Returns the schema for a table.\n\n    Args:\n        table_name: Table to get the schema for.\n        auth: Optional string token or AuthMethod dict for this call.\n\n    Returns:\n        List[Dict[str, str]]: Schema for the table.\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    query = f\"{self.url}/get_table_schema?table_name={table_name}\"\n    return self._do_get_request(query, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.get_tables","title":"<code>get_tables(auth=None)</code>","text":"<p>Returns a dictionary indexed by table name with values the schema for each table.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict to use for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Dict]</code> <p>Dict[Dict]:  Dictionary of table schemas</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def get_tables(self, auth: Optional[Union[str, AuthMethod]] = None) -&gt; Dict[str, Dict]:\n    \"\"\"\n    Returns a dictionary indexed by table name with values the schema for each table.\n\n    Args:\n        auth: Optional string token or AuthMethod dict to use for this call.\n\n    Returns:\n        Dict[Dict]:  Dictionary of table schemas\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    query = f'{self.url}/get_tables'\n    return self._do_get_request(query, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.list_tables","title":"<code>list_tables(auth=None)</code>","text":"<p>Returns a list of table names from the server.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>Optional[Union[str, AuthMethod]]</code> <p>Optional string token or AuthMethod dict to use for this call.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: list of table names.</p> <p>Raises:</p> Type Description <code>SDTPClientError</code> <p>SDTPClientError on a bad response.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def list_tables(self, auth: Optional[Union[str, AuthMethod]] = None) -&gt; List[str]:\n    \"\"\"\n    Returns a list of table names from the server.\n\n    Args:\n        auth: Optional string token or AuthMethod dict to use for this call.\n\n    Returns:\n        List[str]: list of table names.\n\n    Raises:\n        SDTPClientError: SDTPClientError on a bad response.\n    \"\"\"\n    query = f'{self.url}/get_table_names'\n    return self._do_get_request(query, auth)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.query_credential_method","title":"<code>query_credential_method(url=None)</code>","text":"<p>Return the authentication method (AuthMethod) for the specified URL, as stored in this client's credentials mapping.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>The server URL to query (defaults to this client's URL if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[AuthMethod]</code> <p>The AuthMethod dict (e.g., {'env': ...}, {'path': ...}, or {'value': ...}),</p> <code>Optional[AuthMethod]</code> <p>or None if no method is configured for this URL.</p> Example <p>method = client.query_credential_method()</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def query_credential_method(self, url: Optional[str] = None) -&gt; Optional[AuthMethod]:\n    \"\"\"\n    Return the authentication method (AuthMethod) for the specified URL, as stored in this client's credentials mapping.\n\n    Args:\n        url: The server URL to query (defaults to this client's URL if None).\n\n    Returns:\n        The AuthMethod dict (e.g., {'env': ...}, {'path': ...}, or {'value': ...}),\n        or None if no method is configured for this URL.\n\n    Example:\n        method = client.query_credential_method()\n        # returns this client's method\n\n        method = client.query_credential_method(\"https://other.example.com\")\n        # returns method for another URL (if in credentials)\n    \"\"\"\n    effective_url = url if url else self.url\n    return _query_credential_method(self.credentials, effective_url)\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.query_credential_method--returns-this-clients-method","title":"returns this client's method","text":"<p>method = client.query_credential_method(\"https://other.example.com\")</p>"},{"location":"api/#sdtp.sdtp_client.SDTPClient.query_credential_method--returns-method-for-another-url-if-in-credentials","title":"returns method for another URL (if in credentials)","text":""},{"location":"api/#sdtp.sdtp_client.SDTPClient.table_exists","title":"<code>table_exists(table_name, auth=None)</code>","text":"<p>Return True if and only if table table_name exists on the server Args:     table_name: Table to check.     auth: Optional string token or AuthMethod dict for this call. Returns:     bool: True if the table exists, False otherwise.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def table_exists(self, table_name: str, auth: Optional[Union[str, AuthMethod]] = None)-&gt;bool:\n    \"\"\"\n    Return True if and only if table table_name exists on the server\n    Args:\n        table_name: Table to check.\n        auth: Optional string token or AuthMethod dict for this call.\n    Returns:\n        bool: True if the table exists, False otherwise.\n    \"\"\"\n    names = self.get_tables(auth).keys()\n    return table_name in names\n</code></pre>"},{"location":"api/#sdtp.sdtp_client.SDTPClientError","title":"<code>SDTPClientError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for SDTP client errors.</p>"},{"location":"api/#sdtp.sdtp_client.load_config","title":"<code>load_config(config_path=None)</code>","text":"<p>Loads and validates the SDTPClient YAML config file.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, AuthMethod] -- The credentials mapping (URL -&gt; AuthMethod).</p> <p>Raises:     Exception on parse or validation error.</p> Source code in <code>src/sdtp/sdtp_client.py</code> <pre><code>def load_config(config_path: Optional[str] = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Loads and validates the SDTPClient YAML config file.\n\n    Returns:\n        Dict[str, AuthMethod] -- The credentials mapping (URL -&gt; AuthMethod).\n    Raises:\n        Exception on parse or validation error.\n    \"\"\"\n    if config_path is None:\n        config_path = os.environ.get(\"SDTP_CLIENT_CONFIG\", DEFAULT_CONFIG_PATH)\n    config_path = os.path.expanduser(config_path)\n    if not os.path.exists(config_path):\n        # raise FileNotFoundError(f\"Config file not found: {config_path}\")\n        print(f\"Warning: No SDTP config file found at {config_path}. Proceeding with no credentials.\")\n        return {} # Or None\n\n    with open(config_path, \"r\") as f:\n        config = yaml.safe_load(f)\n\n    # Expect config with a 'credentials' mapping\n    creds = config.get(\"credentials\")\n    if not isinstance(creds, dict):\n        raise ValueError(\"Missing or invalid 'credentials' section in config.\")\n\n    for url, method in creds.items():\n        if not isinstance(method, dict) or len(method) != 1 or not any(\n            k in method for k in (\"env\", \"path\", \"value\")\n        ):\n            raise ValueError(f\"Invalid AuthMethod for {url}: {method}\")\n    return creds  # type: Dict[str, AuthMethod]\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.DEFAULT_HEADER_VARIABLES","title":"<code>DEFAULT_HEADER_VARIABLES = {'required': [], 'optional': []}</code>  <code>module-attribute</code>","text":"<p>The Default for header variables for a table is both required and optional lists are empty.</p>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable","title":"<code>RemoteSDMLTable(table_name, schema, url, auth=None, header_dict=None)</code>","text":"<p>               Bases: <code>SDMLTable</code></p> <p>A SDTP Table on a remote server.  This just has a schema, an URL, and  header variables. This is the primary class for the client side of the SDTP, and in many packages would be a separate client module.  However, the SDTP is  designed so that Remote Tables can be used to serve local tables, so this  is part of a server-side framework to. Parameters:     table_name: name of the resmote stable     schema: schema of the remote table     url: url of the server hosting the remore table     auth: dictionary of variables and values required to access the table Throws:     InvalidDataException if the table doesn't exist on the server, the      url is unreachable, the schema doesn't match the downloaded schema</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, table_name, schema, url,  auth = None, header_dict  = None): \n    super(RemoteSDMLTable, self).__init__(schema)\n    self.url = url\n    self.schema: List[ColumnSpec] = schema\n    self.table_name = table_name\n    self.auth = auth\n    self.ok = False\n    self.header_dict = header_dict\n    self.row_table_factory = RowTableFactory()\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable.all_values","title":"<code>all_values(column_name)</code>","text":"<p>get all the values from column_name Arguments:</p> <pre><code>column_name: name of the column to get the values for\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def all_values(self, column_name: str) -&gt; list:\n    '''\n    get all the values from column_name\n    Arguments:\n\n        column_name: name of the column to get the values for\n\n    Returns:\n        list: List of the values\n\n    '''\n    return self._execute_column_route(column_name,  'get_all_values')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable.connect_with_server","title":"<code>connect_with_server()</code>","text":"<p>Connect with the server, ensuring that the server is: a. a SDTP server b. has self.table_name in its list of tables c. the table there has a matching schema</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def connect_with_server(self):\n    '''\n    Connect with the server, ensuring that the server is:\n    a. a SDTP server\n    b. has self.table_name in its list of tables\n    c. the table there has a matching schema\n    '''\n\n    try:\n        response = self._execute_get_request(f'{self.url}/get_tables')\n        if response.status_code &gt;= 300:\n            self._connect_error(f'Bad connection with {self.url}: code {response.status_code}')\n    except Exception as e:\n        self._connect_error(f'Error connecting with {self.url}/get_tables: {repr(e)}')\n    try:\n        server_tables = response.json()\n    except Exception as e:\n        self._connect_error(f'Error {repr(e)} reading tables from  {self.url}/get_tables')\n    if self.table_name in server_tables:\n        server_schema: List[ColumnSpec] = server_tables[self.table_name]\n        self._check_schema_match(server_schema)\n        self.server_schema = server_schema\n    else:\n        self._connect_error(f'Server at {self.url} does not have table {self.table_name}')\n    # if we get here, everything worked:\n    self.ok = True\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable.get_column","title":"<code>get_column(column_name)</code>","text":"<p>get the column  column_name Arguments:     column_name: name of the column to get</p> <p>Returns:</p> Name Type Description <code>List</code> <code>list</code> <p>The column as a list</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_column(self, column_name: str)  -&gt; list:\n    '''\n    get the column  column_name\n    Arguments:\n        column_name: name of the column to get\n\n\n    Returns:\n        List: The column as a list\n    '''\n    return self._execute_column_route(column_name, 'get_column')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable.get_filtered_rows","title":"<code>get_filtered_rows(filter_spec=None, columns=[], format=DEFAULT_FILTERED_ROW_RESULT_FORMAT)</code>","text":"<p>Filter the rows according to the specification given by filter_spec. Returns the rows for which the resulting filter returns True. Reorders columns to match client request, even if remote server responds in different order. This guarantees protocol safety.</p> <p>Parameters:</p> Name Type Description Default <code>filter_spec</code> <code>dict</code> <p>Specification of the filter, as a dictionary</p> <code>None</code> <code>columns</code> <code>list</code> <p>the names of the columns to return.  Returns all columns if absent</p> <code>[]</code> <code>format</code> <code>str</code> <p>one of 'list', 'dict', 'sdml'.  Default is list.  </p> <code>DEFAULT_FILTERED_ROW_RESULT_FORMAT</code> <p>Returns:     The subset of self.get_rows() which pass the filter in the format specified by format</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_filtered_rows(self, filter_spec=None, columns=[], format = DEFAULT_FILTERED_ROW_RESULT_FORMAT) -&gt; Union[list, list[dict[str, Any]], RowTable]:\n    '''\n    Filter the rows according to the specification given by filter_spec.\n    Returns the rows for which the resulting filter returns True.\n    Reorders columns to match client request, even if remote server responds in different order. This guarantees protocol safety.\n\n    Arguments:\n        filter_spec (dict): Specification of the filter, as a dictionary\n        columns (list): the names of the columns to return.  Returns all columns if absent\n        format (str): one of 'list', 'dict', 'sdml'.  Default is list.  \n    Returns:\n        The subset of self.get_rows() which pass the filter in the format specified by format\n    '''\n    # Check to make sure that the format is valid\n    if format is None: format = DEFAULT_FILTERED_ROW_RESULT_FORMAT\n    if columns is None: columns = []\n\n    if format not in ALLOWED_FILTERED_ROW_RESULT_FORMATS:\n        raise InvalidDataException(f'format for get_filtered rows must be one of {ALLOWED_FILTERED_ROW_RESULT_FORMATS}, not {format}')\n    # Note that we don't check if the column names are all valid\n\n    remoteRowTable = self._get_filtered_rows_from_remote(filter_spec, columns=columns)\n    if format == 'list':\n        requestedColumns = self.column_names() if len(columns) == 0 else columns\n        return _generate_ordered_lists(remoteRowTable, self, requestedColumns)\n    elif format == 'dict':\n        result_columns = remoteRowTable.column_names()\n        return [_row_dict(row, result_columns) for row in remoteRowTable.rows]\n    else:\n        return remoteRowTable\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTable.range_spec","title":"<code>range_spec(column_name)</code>","text":"<p>Get the dictionary {min_val, max_val} for column_name Arguments:</p> <pre><code>column_name: name of the column to get the range spec for\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the minimum and  maximum of the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def range_spec(self, column_name: str)  -&gt; list:\n    '''\n    Get the dictionary {min_val, max_val} for column_name\n    Arguments:\n\n        column_name: name of the column to get the range spec for\n\n    Returns:\n        list: the minimum and  maximum of the column\n\n    '''\n    return self._execute_column_route(column_name, 'get_range_spec')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RemoteSDMLTableFactory","title":"<code>RemoteSDMLTableFactory()</code>","text":"<p>               Bases: <code>SDMLTableFactory</code></p> <p>A factory to build RemoteSDMLTables.  build_table is very simple, just instantiating a RemoteSDMLTables on the url and schema of the specification</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self):\n    super(RemoteSDMLTableFactory, self).__init__('RemoteSDMLTable')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RowTable","title":"<code>RowTable(schema, rows)</code>","text":"<p>               Bases: <code>SDMLFixedTable</code></p> <p>A simple utility class to serve data from a static list of rows, which can be constructed from a CSV file, Excel File, etc.  The idea is to make it easy for users to create and upload simple datasets to be served from a general-purpose server.  Note that this will need some authentication.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, schema, rows):\n    self.schema = schema  # set this *before* calling self.column_types()\n    type_list = self.column_types()\n    # print(\"RowTable.__init__ received schema:\", schema)\n    # print(\"RowTable.__init__ received rows:\", rows)\n    # print(\"RowTable.__init__ inferred column types:\", self.column_types(), type_list)\n    self.rows = convert_rows_to_type_list(type_list, rows)\n    super(RowTable, self).__init__(schema, self._get_rows)\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.RowTableFactory","title":"<code>RowTableFactory()</code>","text":"<p>               Bases: <code>SDMLTableFactory</code></p> <p>A factory to build RowTables -- in fact, all SDMLFixedTables.  build_table is very simple, just instantiating a RowTable on the rows and schema of the specification</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self):\n    super(RowTableFactory, self).__init__('RowTable')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLDataFrameTable","title":"<code>SDMLDataFrameTable(schema, dataframe)</code>","text":"<p>               Bases: <code>SDMLFixedTable</code></p> <p>A simple utility class to serve data from a PANDAS DataFrame.  The general idea is  that the values are in the PANDAS Dataframe, which must have the same column names as the schema and compatible types.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, schema, dataframe):\n    super(SDMLDataFrameTable, self).__init__(schema, self._get_rows)\n    self.dataframe = dataframe.copy()\n    # Make sure the column names and types match\n    self.dataframe.columns = self.column_names()\n     # make sure that the types match\n    for column in schema:\n        column_values = self.dataframe[column[\"name\"]].tolist()\n        try:\n            fixed_series = convert_list_to_type(column[\"type\"], column_values)\n            self.dataframe[column[\"name\"]] = fixed_series\n        except Exception as exc:\n            raise InvalidDataException(f'error {exc} converting {column[\"name\"]}')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLDataFrameTable.all_values","title":"<code>all_values(column_name)</code>","text":"<p>get all the values from column_name Arguments:     column_name: name of the column to get the values for</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def all_values(self, column_name: str)  -&gt; list:\n    '''\n    get all the values from column_name\n    Arguments:\n        column_name: name of the column to get the values for\n\n\n    Returns:\n        list: List of the values\n\n    '''\n    type_and_values = self._get_column_and_type(column_name)\n    result = list(set(type_and_values['values']))\n    result.sort()\n    return  result\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLDataFrameTable.get_column","title":"<code>get_column(column_name)</code>","text":"<p>get the column  column_name Arguments:     column_name: name of the column to get </p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values in the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_column(self, column_name: str)  -&gt; list:\n    '''\n    get the column  column_name\n    Arguments:\n        column_name: name of the column to get \n\n\n    Returns:\n        list: List of the values in the column\n\n    '''\n    type_and_values = self._get_column_and_type(column_name)\n    return type_and_values['values']\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLDataFrameTable.range_spec","title":"<code>range_spec(column_name)</code>","text":"<p>Get the dictionary {min_val, max_val} for column_name Arguments:</p> <pre><code>column_name: name of the column to get the range spec for\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the minimum and  maximum of the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def range_spec(self, column_name: str)  -&gt; list:\n    '''\n    Get the dictionary {min_val, max_val} for column_name\n    Arguments:\n\n        column_name: name of the column to get the range spec for\n\n    Returns:\n        list: the minimum and  maximum of the column\n\n    '''\n    type_and_values = self._get_column_and_type(column_name)\n    result = list(set(type_and_values['values'])) \n    if len(result) == 0:\n        return []\n    result.sort()\n    response = [result[0], result[-1]]\n    return response\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable","title":"<code>SDMLFixedTable(schema, get_rows)</code>","text":"<p>               Bases: <code>SDMLTable</code></p> <p>A SDMLFixedTable: This is a convenience class for subclasses which generate a fixed  number of rows locally, independent of filtering. This is instantiated with a function get_rows() which  delivers the rows, rather than having them explicitly in the Table.  Note that get_rows() must return  a list of rows, each of which has the appropriate number of entries of the appropriate types. all_values, range_spec, and _get_filtered_rows_from_filter are all implemented on top of  get_rows.  Note that these methods can be overridden in a subclass if there is a more efficient method than the obvious implementation, which is what's implemented here.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>List</code> <p>a list of records of the form {\"name\": &lt;column_name, \"type\": }. The column_type must be a type from galyleo_constants.SDTP_TYPES. required <code>get_rows</code> <code>Callable</code> <p>a function which returns a list of list of values.  Each component list must have the same length as schema, and the jth element must be of the type specified in the jth element of schema</p> required Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, schema: list, get_rows: Callable[[], List]):\n    super(SDMLFixedTable, self).__init__(schema)\n    self.get_rows = get_rows\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.all_values","title":"<code>all_values(column_name)</code>","text":"<p>get all the values from column_name Arguments:     column_name: name of the column to get the values for</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def all_values(self, column_name: str) -&gt; list:\n    '''\n    get all the values from column_name\n    Arguments:\n        column_name: name of the column to get the values for\n\n\n    Returns:\n        list: List of the values\n\n    '''\n    (values, sdtp_type) = self._get_column_values_and_type(column_name)\n    result = list(set(values))\n    result.sort()\n    return result\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.check_column_type","title":"<code>check_column_type(column_name)</code>","text":"<p>For testing.  Makes sure that all the entries in column_name are the right type No return, but throws an InvalidDataException if there's a bad element in the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def check_column_type(self, column_name):\n    '''\n    For testing.  Makes sure that all the entries in column_name are the right type\n    No return, but throws an InvalidDataException if there's a bad element in the column\n    '''\n    value_list = self.all_values(column_name)\n    required_type = self.get_column_type(column_name)\n    if required_type is not None:\n        bad_values = [val for val in value_list if not type_check(required_type, val)]\n    else:\n        bad_values = []\n    if len(bad_values) &gt; 0:\n        raise InvalidDataException(f'Values {bad_values} could not be converted to {required_type} in column {column_name}')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.get_column","title":"<code>get_column(column_name)</code>","text":"<p>get all the column  column_name Arguments:     column_name: name of the column to get</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The column as a list</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_column(self, column_name: str)  -&gt; list:\n    '''\n    get all the column  column_name\n    Arguments:\n        column_name: name of the column to get\n\n\n    Returns:\n        list: The column as a list\n\n    '''\n    (result, sdtp_type) = self._get_column_values_and_type(column_name)\n    return  result\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.range_spec","title":"<code>range_spec(column_name)</code>","text":"<p>Get the dictionary {min_val, max_val} for column_name Arguments:     column_name: name of the column to get the range spec for</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the minimum and  maximum of the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def range_spec(self, column_name: str) -&gt; list:\n    '''\n    Get the dictionary {min_val, max_val} for column_name\n    Arguments:\n        column_name: name of the column to get the range spec for\n\n    Returns:\n        list: the minimum and  maximum of the column\n\n    '''\n    (values, sdtp_type) = self._get_column_values_and_type(column_name)\n    values.sort()\n    result = [values[0], values[-1]]\n    return result\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Convert the table to a PANDAS DataFrame.  This is very straightforward; just  use get_rows to get the rows and convert the schema to the appropriate dtypes. Note this relies on PANDAS type inference.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def to_dataframe(self):\n    '''\n    Convert the table to a PANDAS DataFrame.  This is very straightforward; just \n    use get_rows to get the rows and convert the schema to the appropriate dtypes.\n    Note this relies on PANDAS type inference.\n    '''\n\n    return  pd.DataFrame(self.get_rows(), columns = self.column_names())\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLFixedTable.to_dictionary","title":"<code>to_dictionary()</code>","text":"<p>Return the intermediate form of this table as a dictioary</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def to_dictionary(self):\n    '''\n    Return the intermediate form of this table as a dictioary\n    '''\n    return {\n        \"type\": \"RowTable\",\n        \"schema\": self.schema,\n        \"rows\": jsonifiable_rows(self.get_rows(), self.column_types())\n    }\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable","title":"<code>SDMLTable(schema)</code>","text":"<p>An SDMLTable.  This is the abstract superclass for all Simple Data Markup Language tables, and  implements the schema methods of every SDML class.  The data methods are implemented by the concrete classes.  Any new SDMLTable class should: 1. Subclass SDMLTable 2. Have a constructor with the argument schema 3. call super(&lt;classname, self).init(schema) in the constructor 4. Implement the methods:     (a) all_values(self, column_name)     (b) range_spec(self, column_nam)     (c) _get_filtered_rows_from_filter(self, filter, columns = None)     (d) to_json(self) where:     i. column_name is the name of the column to get the values/range_spec from     ii. filter is a an instance of SDQLFilter     iii. if columns is not None for get_filtered_rows, only return entries from those columns         in the result from get_filtered_rows Arguments:     schema: a list of records of the form {\"name\": &lt;column_name, \"type\": }.        The column_type must be a type from galyleo_constants.SDTP_TYPES. Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, schema):\n    if type(schema) != list:\n        raise InvalidDataException(f'The schema must be a list of dictionaries, not {type(schema)}')\n    error_entries = [get_errors(entry) for entry in schema]\n    error_entries = [entry for entry in error_entries if len(entry) &gt; 0]\n    if len(error_entries) &gt; 0:\n        raise InvalidDataException(f\"Errors in schema {schema}: {error_entries}\")\n\n    self.schema = schema\n</code></pre> <p>A framework to easily and quickly implement a web server which serves tables according to the SDTP REST  protocol.  This implements the URL methods get_filtered_rows, get_all_values, and get_numeric_spec.  It parses the arguments, checking for errors, takes the table argument, looks up the appropriate SDMLTable to serve for that table, and then calls the method on that server to serve the request.  If no exception is thrown, returns a 200 with the result as a JSON structure, and if an exception is thrown, returns a 400 with an approrpriate error message. All of the methods here except for add_sdtp_table are simply route targets: none are designed for calls from any method other than flask. The way to use this is very simple: 1. For each Table to be served, create an instance of sdtp_table.SDMLTable 2. Call add_sdtp_table(table_name, sdtp_table) After that, requests for the named table will be served by the created data server.</p>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.all_values","title":"<code>all_values(column_name)</code>","text":"<p>get all the values from column_name Arguments:     column_name: name of the column to get the values for</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def all_values(self, column_name: str)  -&gt; list:\n    '''\n    get all the values from column_name\n    Arguments:\n        column_name: name of the column to get the values for\n\n    Returns:\n        list: List of the values\n\n    '''\n    raise InvalidDataException(f'all_values has not been in {type(self)}.__name__')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.column_names","title":"<code>column_names()</code>","text":"<p>Return the names of the columns</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def column_names(self):\n    '''\n    Return the names of the columns\n    '''\n    return [column[\"name\"] for column in self.schema]\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.column_types","title":"<code>column_types()</code>","text":"<p>Return the types of the columns</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def column_types(self):\n    '''\n    Return the types of the columns\n    '''\n    return [column[\"type\"] for column in self.schema]\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.get_column","title":"<code>get_column(column_name)</code>","text":"<p>get the column  column_name Arguments:     column_name: name of the column to get </p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>List of the values in the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_column(self, column_name: str)  -&gt; list:\n    '''\n    get the column  column_name\n    Arguments:\n        column_name: name of the column to get \n\n\n    Returns:\n        list: List of the values in the column\n\n    '''\n    raise InvalidDataException(f'get_column has not been in {type(self)}.__name__')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.get_column_type","title":"<code>get_column_type(column_name)</code>","text":"<p>Returns the type of column column_name, or None if this table doesn't have a column with name  column_name.</p> <p>Parameters:</p> Name Type Description Default <code>column_name</code> <code>str</code> <p>name of the column to get the type for</p> required Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_column_type(self, column_name):\n    '''\n    Returns the type of column column_name, or None if this table doesn't have a column with\n    name  column_name.\n\n    Arguments:\n        column_name(str): name of the column to get the type for\n    '''\n    matches = [column[\"type\"] for column in self.schema if column[\"name\"] == column_name]\n    if len(matches) == 0:\n        return None\n    else:\n        return matches[0]\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.get_filtered_rows","title":"<code>get_filtered_rows(filter_spec=None, columns=[], format=DEFAULT_FILTERED_ROW_RESULT_FORMAT)</code>","text":"<p>Filter the rows according to the specific-ation given by filter_spec. Returns the rows for which the resulting filter returns True.</p> <p>Parameters:</p> Name Type Description Default <code>filter_spec</code> <code>dict</code> <p>Specification of the filter, as a dictionary</p> <code>None</code> <code>columns</code> <code>list</code> <p>the names of the columns to return.  Returns all columns if absent</p> <code>[]</code> <code>format</code> <code>str</code> <p>one of 'list', 'dict', 'sdml'.  Default is list.  </p> <code>DEFAULT_FILTERED_ROW_RESULT_FORMAT</code> <p>Returns:     list: The subset of self.get_rows() which pass the filter in the format specified by format</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_filtered_rows(self, filter_spec=None, columns=[], format = DEFAULT_FILTERED_ROW_RESULT_FORMAT):\n    '''\n    Filter the rows according to the specific-ation given by filter_spec.\n    Returns the rows for which the resulting filter returns True.\n\n    Arguments:\n        filter_spec(dict): Specification of the filter, as a dictionary\n        columns(list): the names of the columns to return.  Returns all columns if absent\n        format(str): one of 'list', 'dict', 'sdml'.  Default is list.  \n    Returns:\n        list: The subset of self.get_rows() which pass the filter in the format specified by format\n    '''\n    # Check to make sure that the format is valid\n    if format is None: format = DEFAULT_FILTERED_ROW_RESULT_FORMAT\n\n    if format not in ALLOWED_FILTERED_ROW_RESULT_FORMATS:\n        raise InvalidDataException(f'format for get_filtered rows must be one of {ALLOWED_FILTERED_ROW_RESULT_FORMATS}, not {format}')\n    if columns is None: columns = []\n    # Note that we don't check if the column names are all valid\n    filter = make_filter(filter_spec) if filter_spec is not None else None\n    rows =  self._get_filtered_rows_from_filter(filter = filter)\n    columns_in_result = self.column_names() if len(columns) == 0 else columns\n    return _convert_filter_result_to_format(rows, columns_in_result, self.schema, format)\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.range_spec","title":"<code>range_spec(column_name)</code>","text":"<p>Get the dictionary {min_val, max_val} for column_name Arguments:</p> <pre><code>column_name: name of the column to get the range spec for\n</code></pre> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the minimum and  maximum of the column</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def range_spec(self, column_name: str) -&gt; list:\n    '''\n    Get the dictionary {min_val, max_val} for column_name\n    Arguments:\n\n        column_name: name of the column to get the range spec for\n\n    Returns:\n        list: the minimum and  maximum of the column\n\n    '''\n    raise InvalidDataException(f'range_spec has not been in {type(self)}.__name__')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.to_dictionary","title":"<code>to_dictionary()</code>","text":"<p>Return the dictionary  of this table, for saving on disk or transmission.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def to_dictionary(self):\n    '''\n    Return the dictionary  of this table, for saving on disk or transmission.\n    '''\n    raise InvalidDataException(f'to_dictionary has not been in {type(self)}.__name__')\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTable.to_json","title":"<code>to_json()</code>","text":"<p>Return the JSON form of this table, for saving on disk or transmission.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def to_json(self):\n    '''\n    Return the JSON form of this table, for saving on disk or transmission.\n    '''\n    # Since the columns are already a dictionary, they are simply directly jsonified.  For the rows,\n    # just use jjson.dumps, making sure to convert types appropriately\n\n    return json.dumps(self.to_dictionary(), default = json_serialize, indent = 2)\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.SDMLTableFactory","title":"<code>SDMLTableFactory(table_type)</code>","text":"<p>A class which builds an SDMLTable of a specific type.  All SDMLTables have a schema, but after that the specification varies, depending on the method the table uses to get the table rows. Specific factories should subclass this and instantiate the class method build_table. The tag is the table type, simply a string which indicates which class of table should be built. A new SDMLTableFactory class should be built for each concrete subclass of SDMLTable, and ideally in the same file.  The SDMLTable subclass should put a \"type\" field in the intermediate form, and the value of \"type\" should be the type built by the SDTP Table field SDMLTableFactory is an abstract class -- each concrete subclass should call the init method on the  table_type on initialization.  build_table is the method which actually builds the table; the superclass  convenience version of the method throws an InvalidDataException if the spec has the wrong table type</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def __init__(self, table_type):\n    self.table_type = table_type\n</code></pre>"},{"location":"api/#sdtp.sdtp_table.get_errors","title":"<code>get_errors(entry)</code>","text":"<p>A Utility to make sure that a schema entry is valid.  It must have a name, a type, both must be strings,  and the type is one of SDML_SCHEMA_TYPES. Arguments:     entry: a dictionary with (at least) the keys name, type Returns:     A list of errors, which will be the empty list if no errors are found.</p> Source code in <code>src/sdtp/sdtp_table.py</code> <pre><code>def get_errors(entry):\n    '''\n    A Utility to make sure that a schema entry is valid.  It must have a name, a type, both must be strings, \n    and the type is one of SDML_SCHEMA_TYPES.\n    Arguments:\n        entry: a dictionary with (at least) the keys name, type\n    Returns:\n        A list of errors, which will be the empty list if no errors are found.\n    '''\n    if not type(entry) == dict:\n        return [f'Schema entry {entry} must be a dictionary, not {type(entry)}']\n    result = []\n    keys = set(entry.keys())\n    if not 'name' in keys:\n        result.append(f'Column {entry} must have a name')\n    elif type(entry['name']) != str:\n        result.append(f'Name of column {entry} must be a string')\n    if not 'type' in keys:\n        result.append(f'Column {entry} must have a type')\n    elif not (type(entry['type']) == str and entry['type'] in SDML_SCHEMA_TYPES):\n        result.append(f'Type of column {entry} must be one of {SDML_SCHEMA_TYPES}' )\n    return result\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.AllFilter","title":"<code>AllFilter</code>","text":"<p>               Bases: <code>CompoundFilter</code></p> <p>An ALL Filter -- matches a row if ALL of the arguments match on the column</p>"},{"location":"api/#sdtp.sdtp_filter.AnyFilter","title":"<code>AnyFilter</code>","text":"<p>               Bases: <code>CompoundFilter</code></p> <p>An ANY Filter -- matches a row if ANY of the arguments match on the column</p>"},{"location":"api/#sdtp.sdtp_filter.ColumnFilter","title":"<code>ColumnFilter</code>","text":"<p>               Bases: <code>SDQLFilter</code></p> <p>Abstract base class for IN_LIST, GE, LE, LT, GT, REGEX_MATCH filters</p>"},{"location":"api/#sdtp.sdtp_filter.ColumnFilter.matches","title":"<code>matches(row, columns)</code>","text":"<p>Every ColumnFilter picks out the appropriate value from the row and runs the test on that,  so do that once, here</p> Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def matches(self, row, columns):\n  \"\"\"\n  Every ColumnFilter picks out the appropriate value from the row and runs the test on that, \n  so do that once, here\n  \"\"\"\n  try:\n    index = columns.index(self.column)\n    return self.matches_value(row[index])\n  except ValueError:\n    return False\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.CompareFilter","title":"<code>CompareFilter</code>","text":"<p>               Bases: <code>ColumnFilter</code></p> <p>Superclass for \"GE\", \"LE\", \"GT\", \"LT\" operators.  Takes care of finding the compare_value and generating the dictionary form</p>"},{"location":"api/#sdtp.sdtp_filter.CompoundFilter","title":"<code>CompoundFilter</code>","text":"<p>               Bases: <code>SDQLFilter</code></p> <p>Superclass for a CompoundFilter (ALL, ANY, or NONE).  Just generates the intermediate form and implements a utility which maps a match across all arguments Arguments:   operator: one of ANY, ALL, or NONE   arguments: set of subfilters</p>"},{"location":"api/#sdtp.sdtp_filter.GEFilter","title":"<code>GEFilter</code>","text":"<p>               Bases: <code>CompareFilter</code></p> <p>Implement &gt;=</p>"},{"location":"api/#sdtp.sdtp_filter.GTFilter","title":"<code>GTFilter</code>","text":"<p>               Bases: <code>CompareFilter</code></p> <p>Implement &gt;</p>"},{"location":"api/#sdtp.sdtp_filter.InListFilter","title":"<code>InListFilter</code>","text":"<p>               Bases: <code>ColumnFilter</code></p> <p>Implement an \"IN_LIST\" filter, which passes all rows in which the  value of column is in the list given by values Arguments:   values: list of values to check for</p>"},{"location":"api/#sdtp.sdtp_filter.LEFilter","title":"<code>LEFilter</code>","text":"<p>               Bases: <code>CompareFilter</code></p> <p>Implement &lt;=</p>"},{"location":"api/#sdtp.sdtp_filter.LTFilter","title":"<code>LTFilter</code>","text":"<p>               Bases: <code>CompareFilter</code></p> <p>Implement &lt;</p>"},{"location":"api/#sdtp.sdtp_filter.NoneFilter","title":"<code>NoneFilter</code>","text":"<p>               Bases: <code>CompoundFilter</code></p> <p>A None Filter -- matches a row if NONE  of the arguments match on the column Arguments:   arguments: set of subfilters</p>"},{"location":"api/#sdtp.sdtp_filter.RegexFilter","title":"<code>RegexFilter</code>","text":"<p>               Bases: <code>ColumnFilter</code></p> <p>Implement a REGEX filter, which passes all rows in which the  value of column matches the regular expression expression</p>"},{"location":"api/#sdtp.sdtp_filter.SDQLFilter","title":"<code>SDQLFilter</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Abstract base class for all filters.</p>"},{"location":"api/#sdtp.sdtp_filter.SDQLFilter.to_filter_spec","title":"<code>to_filter_spec()</code>","text":"<p>Generate a dictionary form of the SDQLFilter.  This is primarily for use on the client side, where A SDQLFilter can be constructed, and then a JSONified form of the dictionary version can be passed to the server for server-side filtering.  It's also useful for testing and debugging Returns:     A dictionary form of the Filter</p> Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def to_filter_spec(self):\n  '''\n  Generate a dictionary form of the SDQLFilter.  This is primarily for use on the client side, where\n  A SDQLFilter can be constructed, and then a JSONified form of the dictionary version can be passed to\n  the server for server-side filtering.  It's also useful for testing and debugging\n  Returns:\n      A dictionary form of the Filter\n  '''\n  raise NotImplementedError(\"to_filter_spec must be implemented by subclass\")\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.check_valid_spec","title":"<code>check_valid_spec(filter_spec)</code>","text":"<p>Method which checks to make sure that a filter spec is valid. Does not return, but throws an InvalidDataException with an error message if the filter spec is invalid</p> <p>Parameters:</p> Name Type Description Default <code>filter_spec</code> <code>dict</code> <p>spec to test for validity</p> required Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def check_valid_spec(filter_spec: dict):\n  '''\n  Method which checks to make sure that a filter spec is valid.\n  Does not return, but throws an InvalidDataException with an error message\n  if the filter spec is invalid\n\n  Arguments:\n    filter_spec (dict): spec to test for validity\n  '''\n  try:\n    f = make_filter(filter_spec)\n  except Exception as e:\n    raise InvalidDataException(e)\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.check_valid_spec_return_boolean","title":"<code>check_valid_spec_return_boolean(filter_spec)</code>","text":"<p>Method which checks to make sure that a filter spec is valid. Returns True if and only if filter_spec has no errors</p> <p>Parameters:</p> Name Type Description Default <code>filter_spec</code> <code>dict</code> <p>spec to test for validity</p> required Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def check_valid_spec_return_boolean(filter_spec: dict):\n  '''\n  Method which checks to make sure that a filter spec is valid.\n  Returns True if and only if filter_spec has no errors\n\n  Arguments:\n    filter_spec(dict): spec to test for validity\n  '''\n  try:\n    f = make_filter(filter_spec)\n    return True\n  except Exception as e:\n    return False\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.expand_in_range_spec","title":"<code>expand_in_range_spec(spec)</code>","text":"<p>Expands an IN_RANGE filter spec into a list of atomic comparison specs.</p> Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def expand_in_range_spec(spec):\n  \"\"\"\n  Expands an IN_RANGE filter spec into a list of atomic comparison specs.\n  \"\"\"\n  min_val = spec.get(\"min_val\")\n  max_val = spec.get(\"max_val\")\n  inclusive = spec.get(\"inclusive\", \"both\")\n  column = spec[\"column\"]\n\n  atomic_specs = []\n  # Left (min)\n  if min_val is not None:\n    op = \"GE\" if inclusive in (\"both\", \"left\") else \"GT\"\n    atomic_specs.append({\"operator\": op, \"column\": column, \"value\": min_val})\n  # Right (max)\n  if max_val is not None:\n    op = \"LE\" if inclusive in (\"both\", \"right\") else \"LT\"\n    atomic_specs.append({\"operator\": op, \"column\": column,  \"value\": max_val})\n  return atomic_specs[0] if len(atomic_specs) == 1 else {\"operator\": \"ALL\", \"arguments\": atomic_specs}\n</code></pre>"},{"location":"api/#sdtp.sdtp_filter.make_filter","title":"<code>make_filter(filter_spec)</code>","text":"<p>Make a filter from a filter_spec.  Note that filter_spec should be free of errors (run filter_spec_errors first) Arguments:   filter_spec: A valid dictionary form of a filter Returns:   An instance of SDQL Filters</p> Source code in <code>src/sdtp/sdtp_filter.py</code> <pre><code>def make_filter(filter_spec):\n  \"\"\"\n  Make a filter from a filter_spec.  Note that filter_spec should\n  be free of errors (run filter_spec_errors first)\n  Arguments:\n    filter_spec: A valid dictionary form of a filter\n  Returns:\n    An instance of SDQL Filters\n  \"\"\"\n  operator = filter_spec[\"operator\"]\n  if operator == \"IN_RANGE\":\n    filter_spec = expand_in_range_spec(filter_spec)\n    operator = filter_spec[\"operator\"]\n\n  cls = FILTER_CLASSES.get(operator)\n  if not cls:\n    raise ValueError(f\"Unknown filter operator: {operator}\")\n  if issubclass(cls, CompoundFilter):\n    return cls(operator = operator, arguments=[make_filter(s) for s in filter_spec[\"arguments\"]])\n  return cls(**filter_spec)\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.SDTPServer","title":"<code>SDTPServer(name, __name__)</code>","text":"<p>               Bases: <code>Blueprint</code></p> <p>An SDTP Server.  This is just an overlay on a Flask Blueprint, added so  we can expose initialize methods to the application</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>def __init__(self, name, __name__):\n    super(SDTPServer, self).__init__(name, __name__)\n    self.table_server = TableServer()\n    self.logger = None\n    self.ROUTES = [\n        {\"url\": \"/get_table_names\", \"method\": \"GET\", \"headers\": \"None\",\n            \"description\": \"Return the list of table names\"},\n        {\"url\": \"/get_table_schema?table_name string, required\", \"method\": \"GET\", \"headers\": \"None\",\n            \"description\": 'Returns the schema of the table as a list of objects.  Each object will  contain the fields \"name\" and \"type\", where \"type\"is an SDML type.'},\n        {\"url\": \"/get_tables\", \"method\": \"GET\", \"headers\": \"None\",\n            \"description\": 'Dumps a JSONIfied dictionary of the form:{table_name: &lt;table_schema&gt;}, where &lt;table_schema&gt; is a dictionary{\"name\": name, \"type\": type}'},\n        {\"url\": \"/get_filtered_rows\", \"method\": \"POST\",\n            \"body\": {\"table\": \" required, the name of the table to get the rows from\",\n                    \"columns\": \" If  present, a list of the names of the columns to fetch\",\n                    \"filter\": \" optional, a filter_spec in the SDTP filter language\"},\n\n            \"description\": \"Get the rows from table table which match filter filter.  If columns is present, return only those columns.  Returns a simple list of lists of columns\"},\n        {\"url\": \"/get_range_spec?column_name string, required&amp;table_name string, required\", \"method\": \"GET\",\n            \"headers\": \"None\",\n            \"description\": \"Get the  minimum and maximum values for column column_name in table table_name, returned as a list [min_val, max_val].\"},\n        {\"url\": \"/get_all_values?column_name string, required&amp;table_name string, required\", \"method\": \"GET\",\n            \"headers\": \"None\",\n            \"description\": \"Get all the distinct values for column column_name in table table_name, returned as a sorted list.\"},\n        {\"url\": \"/get_column?column_name string, required&amp;table_name string, required\", \"method\": \"GET\",\n            \"headers\": \"None\",\n            \"description\": \"Return the column &lt;column_name&gt; in table &lt;table_name&gt; as a list.  The behavior is undefined when the table is infinite\"},\n\n    ]\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_all_values","title":"<code>get_all_values()</code>","text":"<p>Target for the /get_all_values route.  Makes sure that column_name and table_name are  specified in the call, then returns the sorted list of all distinct values in the column.    Aborts with a 400 for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_all_values')\ndef get_all_values():\n    '''\n    Target for the /get_all_values route.  Makes sure that column_name and table_name are  specified in the call, then returns the\n    sorted list of all distinct values in the column.    Aborts with a 400\n    for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.\n\n    '''\n    return _execute_column_operation('/get_all_values')\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_column","title":"<code>get_column()</code>","text":"<p>Target for the /get_column route.  Makes sure that column_name and table_name are  specified in the call, then returns the sorted list of all distinct values in the column.    Aborts with a 400 for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_column')\ndef get_column():\n    '''\n    Target for the /get_column route.  Makes sure that column_name and table_name are  specified in the call, then returns the\n    sorted list of all distinct values in the column.    Aborts with a 400\n    for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.\n\n    '''\n    return _execute_column_operation('/get_column')\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_filtered_rows","title":"<code>get_filtered_rows()</code>","text":"<p>Get the filtered rows from a request.   Gets the filter_spec from the filter  field in the body, the table name from the table field in the body.  If there is a columns field in the body, returns onlyt the named columns.  If there is no filter_spec, returns all rows using server.get_rows(). Aborts with a 400 if there is no table, or if check_valid_spec or get_filtered_rows throws an InvalidDataException, or if the filter_spec is not valid JSON.</p> <p>Returns:</p> Type Description <code>Response</code> <p>The filtered rows as a JSONified list of lists</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_filtered_rows', methods=['POST'])\ndef get_filtered_rows() -&gt; Response:\n    '''\n    Get the filtered rows from a request.   Gets the filter_spec from the filter  field in the body, the table name from the table field\n    in the body.  If there is a columns field in the body, returns\n    onlyt the named columns.  If there is no filter_spec, returns all rows using server.get_rows().\n    Aborts with a 400 if there is no table, or if check_valid_spec or get_filtered_rows throws an InvalidDataException, or if the filter_spec is not valid JSON.\n\n    Returns:\n        The filtered rows as a JSONified list of lists\n    '''\n    try:\n        # print(request.data)\n        json_data = _get_json_body_from_post_request_data(request)\n        filter_spec = _get_post_argument('filter', request.form, json_data)\n        columns = _get_post_argument('columns', request.form, json_data)\n        table_name = _get_post_argument('table', request.form, json_data)\n        format = _get_post_argument('result_format', request.form, json_data)\n        if table_name is None:\n            _log_and_abort('table is a required parameter to get filtererd rows', 400)\n        if format is None:\n            format = DEFAULT_FILTERED_ROW_RESULT_FORMAT\n\n    except JSONDecodeError as error:\n        _log_and_abort(f'Bad arguments to /get_filtered_rows.  Error {error.msg}')\n    table = _table_server('/get_filtered_rows', table_name)\n    if columns is None: columns = []\n    if not isinstance(columns, list):\n        _log_and_abort(f'Columns to /get_filtered_rows must be a list of strings, not {columns}, 400')\n    # Make sure that the columns are all valid columns of this table\n    names = table.column_names()\n    bad_columns = [column for column in columns if column not in names]\n    if (len(bad_columns) &gt; 0):\n        _log_and_abort(f'Bad Columns {bad_columns} sent to /get_filtered_rows, table {table_name}', 400)\n\n    # If there is no filter, just return the table's rows.  If\n    # there is a filter, make sure it's valid and then return the filtered\n    # rows\n    if filter_spec is not None:\n        try:\n            check_valid_spec(filter_spec)\n        except InvalidDataException as invalid_error:\n            _log_and_abort(invalid_error)\n\n    # Check to make sure the requested format is OK\n    if format not in ALLOWED_FILTERED_ROW_RESULT_FORMATS:\n        _log_and_abort(f'Bad result_format {format} requested for get_filtered_rows.  Request format must be in {ALLOWED_FILTERED_ROW_RESULT_FORMATS}')\n\n    result = table.get_filtered_rows(filter_spec=filter_spec, columns=columns, format=format)\n\n    if isinstance(result, RowTable):\n        # Safe to call .to_dictionary()\n        result = result.to_dictionary()\n\n    return Response(\n            dumps(result, default= json_serialize),\n            mimetype = \"application/json\"\n        )\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_range_spec","title":"<code>get_range_spec()</code>","text":"<p>Target for the /get_range_spec route.  Makes sure that column_name and table_name are  specified in the call, then returns the range  spec [min_val, max_val] as a list. Aborts with a 400 for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.</p> Arrguments <p>None</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_range_spec')\ndef get_range_spec():\n    '''\n    Target for the /get_range_spec route.  Makes sure that column_name and table_name are  specified in the call, then returns the\n    range  spec [min_val, max_val] as a list. Aborts with a 400\n    for missing arguments, missing table, bad column name or if there is no column_name in the arguments, and a 403 if the table is not authorized.\n\n    Arrguments:\n            None\n    '''\n    return _execute_column_operation('/get_range_spec')\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_table_names","title":"<code>get_table_names()</code>","text":"<p>Target for the /get_table_names route.  Returns the list of names of tables hosted by this server, as a simple list of strings. Parameters: none Errors: none</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_table_names')\ndef get_table_names():\n    '''\n    Target for the /get_table_names route.  Returns the list of names of tables hosted by this server, as a simple list of strings.\n    Parameters: none\n    Errors: none\n    '''\n    return jsonify(list(sdtp_server_blueprint.table_server.servers.keys()))\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_table_schema","title":"<code>get_table_schema()</code>","text":"<p>Target for the /get_table_schema.  Returns the schema of the table as a list of objects.  Each object will contain the fields \"name\" and \"type\", where \"type\" is an SDML type. Returns 400 if the table is not found. Arguments:         table_name: the name of the table</p> Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_table_schema')\ndef get_table_schema():\n    '''\n    Target for the /get_table_schema.  Returns the schema of the table as a list\n    of objects.  Each object will contain the fields \"name\" and \"type\", where \"type\"\n    is an SDML type.\n    Returns 400 if the table is not found.\n    Arguments:\n            table_name: the name of the table\n    '''\n    _check_required_parameters('/get_table_schema', ['table_name'])\n    table_name = request.args.get('table_name')\n    assert table_name is not None # shuts PyLance up -- this is guaranteed, otherwise _check_required_parameters would have aborted\n    table = _table_server('/get_table_schema', table_name)\n    return jsonify(table.schema)\n</code></pre>"},{"location":"api/#sdtp.sdtp_server.get_tables","title":"<code>get_tables()</code>","text":"<p>Target for the /get_tables route.  Dumps a JSONIfied dictionary of the form: {table_name: }, where  is a dictionary {\"name\": name, \"type\": type} Source code in <code>src/sdtp/sdtp_server.py</code> <pre><code>@sdtp_server_blueprint.route('/get_tables')\ndef get_tables():\n    '''\n    Target for the /get_tables route.  Dumps a JSONIfied dictionary of the form:\n    {table_name: &lt;table_schema&gt;}, where &lt;table_schema&gt; is a dictionary\n    {\"name\": name, \"type\": type}\n\n    '''\n    items = sdtp_server_blueprint.table_server.servers.items()\n    result = {}\n    for (name, table) in items:\n        result[name] = table.schema\n\n    return jsonify(result)\n</code></pre> <p>Middleware for a server deployment.  This is designed to sit between the SDTP objects (in sdtp) and a server.  These objects provide two principal functions: 1. Keep the set of tables by name 2. Handle authentication on a table-specific basis 3. Convert results into the wire format for transmission</p> <p>There are two major classes:  1. Table, which provides a wrapper around the SDTP Table with the table's    name, authentication requirememts, and result-conversion utilities 2. TableServer, which provides a registry and lookup service to Tables</p>"},{"location":"api/#sdtp.table_server.ColumnNotFoundException","title":"<code>ColumnNotFoundException(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception that is thrown when a column is not found for a specific table</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def __init__(self, message):\n    super().__init__(message)\n</code></pre>"},{"location":"api/#sdtp.table_server.FileTableLoader","title":"<code>FileTableLoader(spec)</code>","text":"<p>               Bases: <code>TableLoader</code></p> <p>Loads a table from a path</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def __init__(self, spec):\n    self.path = spec[\"path\"]\n</code></pre>"},{"location":"api/#sdtp.table_server.HeaderInfo","title":"<code>HeaderInfo(spec, error_on_missing_env=True)</code>","text":"<p>Supports loading headers from file or env according to our spec: - {\"from_file\": \"path/to/headers.json\"} - {\"headers\": {\"Authorization\": {\"from_env\": \"API_AUTH\"}}}</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def __init__(self, spec, error_on_missing_env=True):\n    self.headers_dict = {}\n\n    if spec is None:\n        return\n\n    # Case 1: Load headers from a JSON file\n    if \"from_file\" in spec:\n        if not os.path.exists(spec[\"from_file\"]):\n            raise FileNotFoundError(f\"Header file not found: {spec['from_file']}\")\n        with open(spec[\"from_file\"], \"r\") as f:\n            data = load(f)\n            if not isinstance(data, dict):\n                raise ValueError(f\"Headers file must be a JSON object (dict), got {type(data)}\")\n            # No inline validation: assume secret file is trusted\n            self.headers_dict = data\n\n    # Case 2: Load each header from an env var\n    elif \"headers\" in spec:\n        headers_spec = spec[\"headers\"]\n        if not isinstance(headers_spec, dict):\n            raise ValueError(f\"'headers' must be a dict, got {type(headers_spec)}\")\n        for k, v in headers_spec.items():\n            if isinstance(v, dict) and \"from_env\" in v:\n                env_key = v[\"from_env\"]\n                env_val = os.environ.get(env_key)\n                if env_val is None:\n                    msg = f\"Environment variable '{env_key}' for header '{k}' is not set.\"\n                    if error_on_missing_env:\n                        raise EnvironmentError(msg)\n                    else:\n                        print(f\"Warning: {msg} (header omitted)\")\n                        continue\n                self.headers_dict[k] = env_val\n            else:\n                raise ValueError(f\"Header '{k}' value must be a dict with 'from_env', got {v}\")\n    else:\n        raise ValueError(\"auth_info must contain 'from_file' or 'headers' as its only key.\")\n\n    # Strict: Disallow extra keys\n    allowed_keys = {\"from_file\", \"headers\"}\n    extra_keys = set(spec.keys()) - allowed_keys\n    if extra_keys:\n        raise ValueError(f\"auth_info has unsupported keys: {extra_keys}\")\n</code></pre>"},{"location":"api/#sdtp.table_server.TableLoader","title":"<code>TableLoader</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api/#sdtp.table_server.TableLoader.load","title":"<code>load()</code>  <code>abstractmethod</code>","text":"<p>Returns a dict spec for the table</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>@abstractmethod\ndef load(self):\n    \"\"\"Returns a dict spec for the table\"\"\"\n</code></pre>"},{"location":"api/#sdtp.table_server.TableNotFoundException","title":"<code>TableNotFoundException(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception that is thrown when a table is not found in the TableServer</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def __init__(self, message):\n    super().__init__(message)\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer","title":"<code>TableServer()</code>","text":"<p>The server for tables.  Its task is to maintain a correspondence between table names and the actual tables.  It also maintains the security information for a table (the variables and values required to access the table), and gives column information across tables</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def __init__(self):\n    self.servers = {}\n    self.factories = {}\n    self.loaders = {\n        \"file\": FileTableLoader,\n        \"uri\": HTTPTableLoader,\n        # Add additional loaders here as needed\n    }\n\n    # factories which are part of the standard  distribution\n    self.add_table_factory(RowTableFactory())\n    self.add_table_factory(RemoteSDMLTableFactory())\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.add_sdtp_table","title":"<code>add_sdtp_table(table_name, sdtp_table)</code>","text":"<p>Register a SDMLTable to serve data for a specific table name. Raises an InvalidDataException if table_name is None or sdtp_table is None or is not an instance of SDMLTable.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>name of the table</p> required <code>sdtp_table</code> <code>SDMLTable</code> <p>table to add</p> required Source code in <code>src/sdtp/table_server.py</code> <pre><code>def add_sdtp_table(self, table_name, sdtp_table):\n    '''\n    Register a SDMLTable to serve data for a specific table name.\n    Raises an InvalidDataException if table_name is None or sdtp_table is None or is not an instance of SDMLTable.\n\n    Arguments:\n        table_name (str): name of the table\n        sdtp_table (SDMLTable): table to add\n\n    '''\n    _check_type(sdtp_table, SDMLTable, 'The sdtp_table argument to add_sdtp_table must be a Table, not')\n    self.servers[table_name] = sdtp_table\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.add_sdtp_table_from_dictionary","title":"<code>add_sdtp_table_from_dictionary(name, table_dictionary)</code>","text":"<p>Add an  SDMLTable from a dictionary (intermediate on-disk form).   The table dictionary has fields schema and type, and then type- specific fields.  Calls self.factories[table_dictionary[\"type\"]] to build the table, then calls self.add_sdtp_table to add the table. Raises an InvalidDataException if self.add_sdtp_table raises it or if the factory  is not present, or if the factory raises an exception</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the table</p> required <code>table_dictionary</code> <code>dict</code> <p>dictionary of the form {\"type\", \"table\"}, where table is a table specification: a dictionary              with the fields type and schema</p> required Source code in <code>src/sdtp/table_server.py</code> <pre><code>def add_sdtp_table_from_dictionary(self, name, table_dictionary):\n    '''\n    Add an  SDMLTable from a dictionary (intermediate on-disk form).   The table dictionary has fields schema and type, and then type-\n    specific fields.  Calls self.factories[table_dictionary[\"type\"]] to build the table,\n    then calls self.add_sdtp_table to add the table.\n    Raises an InvalidDataException if self.add_sdtp_table raises it or if the factory \n    is not present, or if the factory raises an exception\n\n    Arguments:\n        name (str): the name of the table\n        table_dictionary (dict): dictionary of the form {\"type\", \"table\"}, where table is a table specification: a dictionary\n                         with the fields type and schema\n\n    '''\n\n    _check_dict_and_keys(table_dictionary, {'type', 'schema'}, 'table_dictionary must be a dictionary not', 'table_dictionary')\n    table_type = table_dictionary['type']\n    if table_type in self.factories.keys():\n        table = self.factories[table_type].build_table(table_dictionary)\n        self.add_sdtp_table(name,  table)\n    else:\n        raise InvalidDataException(f'No factory registered for {table_type}')\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.add_table_factory","title":"<code>add_table_factory(table_factory)</code>","text":"<p>Add a TableFactory for table type table_type.  When  self.add_table_from_dictionary(table_spec) is called, the appropriate  factory is called to build it Arguments:    table_factory: an instance of a subclass of TableFactory which actually builds the table</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def add_table_factory(self, table_factory):\n    '''\n    Add a TableFactory for table type table_type.  When \n    self.add_table_from_dictionary(table_spec) is called, the appropriate \n    factory is called to build it\n    Arguments:\n       table_factory: an instance of a subclass of TableFactory which actually builds the table\n    '''\n    # Check the table factory extends SDMLTableFactory\n    _check_type(table_factory, SDMLTableFactory, 'table_factory must be an instance of SDMLTableFactory, not')\n    table_type = table_factory.table_type\n\n    _check_type(table_type, str, 'table_type must be a string, not')\n    self.factories[table_type] = table_factory\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.get_all_tables","title":"<code>get_all_tables()</code>","text":"<p>Get all the tables.  This is to support a request for a numeric_spec or all_values for a column name when the table_name is not specified. In this case, all tables will be searched for this column name.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of all tables</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def get_all_tables(self) -&gt; list:\n    '''\n    Get all the tables.  This\n    is to support a request for a numeric_spec or all_values for a column name when the\n    table_name is not specified. In this case, all tables will be searched for this column name.\n\n\n    Returns:\n        list: a list of all tables\n    '''\n    tables = self.servers.values()\n    return list(tables)\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.get_all_values","title":"<code>get_all_values(table_name, column_name)</code>","text":"<p>Get all of the distinct values for column column_name for table table_name.  Returns the list of distinct values for the columns Arguments:     table_name (str): table to be searched     column_name (str): name of the column</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Returns the list of distinct values for the columns</p> <p>Raises:     TableNotFoundException if the table is not found     ColumnNotFoundException if the column can't be found</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def get_all_values(self, table_name, column_name) -&gt; list:\n    '''\n    Get all of the distinct values for column column_name for table\n    table_name.  Returns the list of distinct values for the columns\n    Arguments:\n        table_name (str): table to be searched\n        column_name (str): name of the column\n\n    Returns:\n        list: Returns the list of distinct values for the columns\n    Raises:\n        TableNotFoundException if the table is not found\n        ColumnNotFoundException if the column can't be found\n    '''\n\n    _check_type(column_name, str, 'Column name must be a string, not')\n    table = self.get_table(table_name)  # Note this will throw the TableNotFoundException\n\n    try:\n        return table.all_values(column_name)\n    except InvalidDataException:\n        raise ColumnNotFoundException(f'Column {column_name} not found in table {table_name}')\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.get_column","title":"<code>get_column(table_name, column_name)</code>","text":"<p>Get the column for column column_name for table table_name.  Returns the column as a list Arguments:     table_name: table to be searched     column_name: name of the column</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Returns  a dictionary with keys{max_val, min_val}</p> <p>Raises:     TableNotFoundException if the table is not found     ColumnNotFoundException if the column can't be found</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def get_column(self, table_name, column_name) -&gt; list:\n    '''\n    Get the column for column column_name for table\n    table_name.  Returns the column as a list\n    Arguments:\n        table_name: table to be searched\n        column_name: name of the column\n\n    Returns:\n        list: Returns  a dictionary with keys{max_val, min_val}\n    Raises:\n        TableNotFoundException if the table is not found\n        ColumnNotFoundException if the column can't be found\n    '''\n    _check_type(column_name, str, 'Column name must be a string, not')\n    table = self.get_table(table_name)  # Note this will throw the TableNotFoundException\n    try:\n        return table.get_column(column_name)\n    except InvalidDataException:\n        raise ColumnNotFoundException(f'Column {column_name} not found in table {table_name}')\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.get_range_spec","title":"<code>get_range_spec(table_name, column_name)</code>","text":"<p>Get the range specification for column column_name for table table_name.  Returns  a two-length list [min_val, max_val] Arguments:     table_name: table to be searched     column_name: name of the column</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Returns  a dictionary with keys{max_val, min_val}</p> <p>Raises:     TableNotFoundException if the table is not found     ColumnNotFoundException if the column can't be found</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def get_range_spec(self, table_name, column_name) -&gt; list:\n    '''\n    Get the range specification for column column_name for table\n    table_name.  Returns  a two-length list [min_val, max_val]\n    Arguments:\n        table_name: table to be searched\n        column_name: name of the column\n\n    Returns:\n        list: Returns  a dictionary with keys{max_val, min_val}\n    Raises:\n        TableNotFoundException if the table is not found\n        ColumnNotFoundException if the column can't be found\n    '''\n    _check_type(column_name, str, 'Column name must be a string, not')\n    table = self.get_table(table_name)  # Note this will throw the TableNotFoundException\n    try:\n        return table.range_spec(column_name)\n    except InvalidDataException:\n        raise ColumnNotFoundException(f'Column {column_name} not found in table {table_name}')\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.get_table","title":"<code>get_table(table_name)</code>","text":"<p>Get the table with name table_name, first checking to see if  table access is authorized by the passed headers. Arguments:     table_name: name of the table to search for</p> <p>Returns:</p> Name Type Description <code>SDMLTable</code> <code>SDMLTable</code> <p>The SDML table corresponding to the request</p> <p>Raises:     TableNotFoundException if the table is not found</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def get_table(self, table_name) -&gt; SDMLTable:\n    '''\n    Get the table with name table_name, first checking to see\n    if  table access is authorized by the passed headers.\n    Arguments:\n        table_name: name of the table to search for\n\n    Returns:\n        SDMLTable: The SDML table corresponding to the request\n    Raises:\n        TableNotFoundException if the table is not found\n\n    '''\n    try:\n        return self.servers[table_name]\n\n    except KeyError:\n        raise TableNotFoundException(f'Table {table_name} not found')\n</code></pre>"},{"location":"api/#sdtp.table_server.TableServer.init_from_config","title":"<code>init_from_config(config_path)</code>","text":"<p>Initialize TableServer from config file. Config must be a JSON list as specified above.</p> Source code in <code>src/sdtp/table_server.py</code> <pre><code>def init_from_config(self, config_path):\n    \"\"\"\n    Initialize TableServer from config file.\n    Config must be a JSON list as specified above.\n    \"\"\"\n    with open(config_path, \"r\") as f:\n        config = load(f)\n\n    for entry in config:\n        name = entry[\"name\"]\n        load_spec = entry[\"load_spec\"]\n\n        location_type = load_spec[\"location_type\"]\n        loader_cls = self.loaders.get(location_type)\n        if loader_cls is None:\n            raise ValueError(f\"No loader for location_type '{location_type}'\")\n\n        loader = loader_cls(load_spec)\n        table_spec = loader.load()  # Should return a dict\n\n        # Figure out the table type (e.g. \"row\", \"remote\") from the spec\n        table_type = table_spec.get(\"type\")\n        if table_type is None:\n            raise ValueError(f\"Missing 'type' field in table spec for '{name}'\")\n\n        factory_cls = self.factories.get(table_type)\n        if factory_cls is None:\n            raise ValueError(f\"No factory registered for table type '{table_type}'\")\n\n        factory = factory_cls\n        table = factory.build_table(table_spec)\n        self.add_sdtp_table(name, table)\n</code></pre>"},{"location":"api/#sdtp.sdtp_schema.BaseTableSchema","title":"<code>BaseTableSchema</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The base schema for a Table.  A Table MUST have a type, which is a valid table, and a schema, which is a ColumnSpec</p>"},{"location":"api/#sdtp.sdtp_schema.ColumnSpec","title":"<code>ColumnSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A column is a dictionary: {\"name\", \"type\"} where</p>"},{"location":"api/#sdtp.sdtp_schema.RemoteAuthSpec","title":"<code>RemoteAuthSpec</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Specification of a Remote Authentication, for use with RemoteTables. It currently supports tokens, env variables, and</p>"},{"location":"api/#sdtp.sdtp_schema.RemoteTableSchema","title":"<code>RemoteTableSchema</code>","text":"<p>               Bases: <code>BaseTableSchema</code></p> <p>The schema for a RemoteTable.  The type of a RemoteTable is \"remote\", and it must have  \"url\" and \"table_name\" fields.  An auth field is optional</p>"},{"location":"api/#sdtp.sdtp_schema.RowTableSchema","title":"<code>RowTableSchema</code>","text":"<p>               Bases: <code>BaseTableSchema</code></p> <p>The schema for a RowTable.  The type of a RowTable is \"row\", and it must have a \"rows\" field</p>"},{"location":"api/#sdtp.sdtp_schema.is_valid_sdml_type","title":"<code>is_valid_sdml_type(t)</code>","text":"<p>Returns True iff t is a valid SDML Type ([\"string\", \"number\", \"boolean\", \"date\", \"datetime\", \"timeofday\"]) Argument:   t: a string</p> Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def is_valid_sdml_type(t: str) -&gt; bool:\n    '''\n    Returns True iff t is a valid SDML Type ([\"string\", \"number\", \"boolean\", \"date\", \"datetime\", \"timeofday\"])\n    Argument:\n      t: a string\n    '''\n    return t in SDML_SCHEMA_TYPES\n</code></pre>"},{"location":"api/#sdtp.sdtp_schema.make_table_schema","title":"<code>make_table_schema(columns)</code>","text":"<p>Given a list of tuples of the form ( ), return an SDTP table schema, which is a list sdtp_schema.ColumnSpec.  Raises an SDTPClientError for an invalid type (type is not a member of sdtp_schema.SDMLType Args:     columns: List[Tuple[str, Literal[\"string\", \"number\", \"boolean\", \"date\", \"datetime\", \"timeofday\"]]]: list of tuples of the form ( ) Returns:     The appropriate  table schema Raises:     ValueError if a type is not a valid  sdtp_schema.SDMLType Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def make_table_schema(columns: List[Tuple[str, Literal[\"string\", \"number\", \"boolean\", \"date\", \"datetime\", \"timeofday\"]]]) -&gt; List[ColumnSpec]:\n    \"\"\"\n    Given a list of tuples of the form (&lt;name&gt; &lt;type&gt;), return an SDTP table schema,\n    which is a list sdtp_schema.ColumnSpec.  Raises an SDTPClientError for an invalid type (type is not a member of sdtp_schema.SDMLType\n    Args:\n        columns: List[Tuple[str, Literal[\"string\", \"number\", \"boolean\", \"date\", \"datetime\", \"timeofday\"]]]: list of tuples of the form (&lt;name&gt; &lt;type&gt;)\n    Returns:\n        The appropriate  table schema\n    Raises:\n        ValueError if a type is not a valid  sdtp_schema.SDMLType\n    \"\"\"\n    errors = [column[1] for column in columns if column[1] not in SDML_SCHEMA_TYPES]\n    if len(errors) &gt; 0:\n        raise ValueError(f'Invalid types {errors} sent to make_table_schema.  Valid types are {SDML_SCHEMA_TYPES}')\n    return  [{\"name\": column[0], \"type\": column[1]} for column in columns]\n</code></pre> <p>Constants and utilities for the Simple Data Transfer Protocol</p>"},{"location":"api/#sdtp.sdtp_schema.type_check","title":"<code>type_check(sdml_type, val)</code>","text":"<p>Check to make sure that the Python type of val matches the implementation of sdml_type Arguments:   sdml_type: an SDMLType ()   val:  a Python value (can be anything)</p> Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def type_check(sdml_type: str, val) -&gt; bool:\n    '''\n    Check to make sure that the Python type of val matches the implementation\n    of sdml_type\n    Arguments:\n      sdml_type: an SDMLType ()\n      val:  a Python value (can be anything)\n    '''\n    \"\"\"Check whether a value matches the given SDML type.\"\"\"\n    return type(val) in SDML_PYTHON_TYPES[sdml_type]\n</code></pre>"},{"location":"api/#sdtp.sdtp_schema.validate_column_spec","title":"<code>validate_column_spec(col)</code>","text":"<p>Validates that the given column dictionary includes required fields and a valid SDML type. Raises ValueError if invalid.</p> Argument <p>col: a dictionary</p> Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def validate_column_spec(col: dict) -&gt; None:\n    '''\n\n    Validates that the given column dictionary includes required fields and a valid SDML type.\n    Raises ValueError if invalid.\n\n    Argument:\n      col: a dictionary\n    '''\n    if \"name\" not in col or \"type\" not in col:\n        raise ValueError(\"Column spec must include 'name' and 'type'\")\n    if not is_valid_sdml_type(col[\"type\"]):\n        raise ValueError(f\"Invalid SDML type: {col['type']}\")\n</code></pre>"},{"location":"api/#sdtp.sdtp_schema.validate_remote_auth","title":"<code>validate_remote_auth(auth)</code>","text":"<p>Ensure that the selected auth type has the required parameters. Throws a ValueError if the auth type is unrecognized or the required parameter is not present.</p> Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def validate_remote_auth(auth: dict) -&gt; None:\n    '''\n    Ensure that the selected auth type has the required parameters.\n    Throws a ValueError if the auth type is unrecognized or the required\n    parameter is not present.\n    '''\n    required_fields = {\n        'env': 'env_var',\n        'file': 'path',\n        'token': 'value'\n    }\n    if not 'type' in auth:\n        raise ValueError(f'Authorization object {auth} must have a type')\n    if not auth['type'] in required_fields:\n        raise ValueError(f'Authorization type {auth[\"type\"]} is invalid.  Valid types are {required_fields.keys()}')\n    required_field = required_fields[auth['type']]\n    if required_field not in auth:\n        raise ValueError(f'{auth[\"type\"]} requires parameter {required_field} but this is not present in {auth}')\n</code></pre>"},{"location":"api/#sdtp.sdtp_schema.validate_table_schema","title":"<code>validate_table_schema(table_schema)</code>","text":"<p>Validates a table schema dictionary against known SDML types and structure. Raises ValueError on failure.</p> <p>This function supports both 'schema' and 'columns' as input keys for column definitions, but normalizes the schema in-place to use 'columns'. This ensures compatibility with legacy schemas while standardizing all downstream usage to 'columns'. Argument:     table_schema: the schema as a dictionary</p> Source code in <code>src/sdtp/sdtp_schema.py</code> <pre><code>def validate_table_schema(table_schema: dict) -&gt; None:\n    \"\"\"\n    Validates a table schema dictionary against known SDML types and structure.\n    Raises ValueError on failure.\n\n    This function supports both 'schema' and 'columns' as input keys for column definitions,\n    but normalizes the schema in-place to use 'columns'. This ensures compatibility with\n    legacy schemas while standardizing all downstream usage to 'columns'.\n    Argument:\n        table_schema: the schema as a dictionary\n    \"\"\"\n    schema_keys = [\"columns\", \"schema\"]\n    chosen_keys = [key for key in schema_keys if key in table_schema]\n    if len(chosen_keys) == 0:\n        raise ValueError(f\"Schema {table_schema} must include a 'schema' or 'columns' list\")\n    elif len(chosen_keys) == 2:\n        raise ValueError(f\"Schema {table_schema} can only contain one of 'schema', 'columns'\")\n    chosen_key = chosen_keys[0]\n    if chosen_key == 'schema': # normalise to columns\n        table_schema[\"columns\"] = table_schema.pop(\"schema\")\n    if not isinstance(table_schema[\"columns\"], list):\n        raise ValueError(f\"{table_schema[chosen_key]} must be a list of columns\")\n\n    for col in table_schema['columns']:\n        validate_column_spec(col)\n\n    table_type = table_schema.get(\"type\")\n    if not table_type:\n        raise ValueError(\"Schema must include a 'type' field\")\n\n    required_fields_by_type = {\n        \"RemoteSDMLTable\": {\"url\", \"table_name\"},\n        \"RowTable\": {\"rows\"}\n    }\n\n    if table_type not in required_fields_by_type:\n        raise ValueError(f\"Unknown or unsupported table type: {table_type}\")\n\n    if table_type == \"remote\" and \"auth\" in table_schema:\n        validate_remote_auth(table_schema[\"auth\"])\n\n    _check_required_fields(table_schema, table_type, required_fields_by_type[table_type])\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.EnvAuthMethod","title":"<code>EnvAuthMethod</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The authentication token is in an the environment variable env</p>"},{"location":"api/#sdtp.sdtp_utils.InvalidDataException","title":"<code>InvalidDataException(message)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>An exception thrown when a data table (list of rows) doesn't match an accoompanying schema,  or a bad schema is specified, or a table row is the wrong length, or..</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def __init__(self, message):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.PathAuthMethod","title":"<code>PathAuthMethod</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The authentication token is in the file at path</p>"},{"location":"api/#sdtp.sdtp_utils.ValueAuthMethod","title":"<code>ValueAuthMethod</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The authentication token is the value</p>"},{"location":"api/#sdtp.sdtp_utils.check_sdml_type_of_list","title":"<code>check_sdml_type_of_list(sdml_type, list_of_values)</code>","text":"<p>Check to make sure the values in list_of_values are all the right Python  type for operations. Arguments:     sdml_type: One of SDML_SCHEMA_TYPES     list_of_values: a Python list to be tested</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def check_sdml_type_of_list(sdml_type, list_of_values):\n    '''\n    Check to make sure the values in list_of_values are all the right Python \n    type for operations.\n    Arguments:\n        sdml_type: One of SDML_SCHEMA_TYPES\n        list_of_values: a Python list to be tested\n    '''\n    type_check_list = [type_check(sdml_type, val) for val in list_of_values]\n    return not (False in type_check_list)\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.convert_dict_to_type","title":"<code>convert_dict_to_type(sdml_type, value_dict)</code>","text":"<p>Convert value_dict to sdml_type, so that comparisons can be done.  Currently only works for lists of string, number, and boolean.</p> <p>Returns a default value if value can't be converted Note that it's the responsibility of the object which provides the rows to always provide the correct types, so this really should always just return a new copy of value_list Arguments:     sdml_type: type to convert to     value_dict: dictionary of values to be converted Returns:     value_dict with each value in the dictionary cast to the correct type</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def convert_dict_to_type(sdml_type, value_dict):\n    '''\n    Convert value_dict to sdml_type, so that comparisons can be done.  Currently only works for lists of string, number, and boolean.\n\n    Returns a default value if value can't be converted\n    Note that it's the responsibility of the object which provides the rows to always provide the correct types,\n    so this really should always just return a new copy of value_list\n    Arguments:\n        sdml_type: type to convert to\n        value_dict: dictionary of values to be converted\n    Returns:\n        value_dict with each value in the dictionary cast to the correct type\n    '''\n    result = {}\n    try:\n        for (key, value) in value_dict.items():\n            result[key] = convert_to_type(sdml_type, value)\n        return result\n    except Exception as exc:\n        raise InvalidDataException(f'Failed to convert {value_dict} to {sdml_type}')\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.convert_list_to_type","title":"<code>convert_list_to_type(sdml_type, value_list)</code>","text":"<p>Convert value_list to sdml_type, so that comparisons can be done.  Currently only works for lists of string, number, and boolean. Returns a default value if value can't be converted Note that it's the responsibility of the object which provides the rows to always provide the correct types, so this really should always just return a new copy of value_list Arguments:     sdml_type: type to convert to     value_list: list of values to be converted Returns:     value_list with each element cast to the correct type</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def convert_list_to_type(sdml_type, value_list):\n    '''\n    Convert value_list to sdml_type, so that comparisons can be done.  Currently only works for lists of string, number, and boolean.\n    Returns a default value if value can't be converted\n    Note that it's the responsibility of the object which provides the rows to always provide the correct types,\n    so this really should always just return a new copy of value_list\n    Arguments:\n        sdml_type: type to convert to\n        value_list: list of values to be converted\n    Returns:\n        value_list with each element cast to the correct type\n    '''\n    try:\n        return  [convert_to_type(sdml_type, elem) for elem in value_list]\n\n        # result = []\n        # for i in range(len(value_list)): result.append(convert_to_type(sdml_type, value_list[i]))\n        # return result\n    except Exception as exc:\n        raise InvalidDataException(f'Failed to convert {value_list} to {sdml_type}')\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.convert_rows_to_type_list","title":"<code>convert_rows_to_type_list(sdml_type_list, rows)</code>","text":"<p>Convert the list of rows to the</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def convert_rows_to_type_list(sdml_type_list, rows):\n    '''\n    Convert the list of rows to the \n    '''\n    length = len(sdml_type_list)\n\n\n    for row in rows:\n        # print(\"convert_rows_to_type_list received types:\", sdml_type_list)\n        # print(\"Row:\", row)\n        # print(\"Expected length:\", length, \"Actual length:\", len(row))\n\n        if len(row) != length:\n            raise InvalidDataException(f'Length mismatch: required number of columns {length}, length {row} = {len(row)}')\n    return  [convert_row_to_type_list(sdml_type_list, row) for row in rows]\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.convert_to_type","title":"<code>convert_to_type(sdml_type, value)</code>","text":"<p>Convert value to sdml_type, so that comparisons can be done.  This is used to convert the values in a filter_spec to a form that can be used in a filter. Throws an InvalidDataException if the type can't be converted. An exception is Boolean, where \"True, true, t\" are all converted to True, but any other values are converted to False</p> <p>Parameters:</p> Name Type Description Default <code>sdml_type</code> <code>str</code> <p>type to convert to</p> required <code>value</code> <code>Any</code> <p>value to be converted</p> required <p>Returns:     value cast to the correct type</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def convert_to_type(sdml_type, value):\n    '''\n    Convert value to sdml_type, so that comparisons can be done.  This is used to convert\n    the values in a filter_spec to a form that can be used in a filter.\n    Throws an InvalidDataException if the type can't be converted.\n    An exception is Boolean, where \"True, true, t\" are all converted to True, but any\n    other values are converted to False\n\n    Arguments:\n        sdml_type (str): type to convert to\n        value (Any): value to be converted\n    Returns:\n        value cast to the correct type\n    '''\n    if type(value) in SDML_PYTHON_TYPES[sdml_type]:\n        return value\n    if sdml_type == \"string\":\n        if isinstance(value, str):\n            return value\n        try:\n            return str(value)\n        except ValueError:\n            raise InvalidDataException('Cannot convert value to string')\n    elif sdml_type == \"number\":\n        return _convert_to_number(value)\n    elif sdml_type == \"boolean\":\n        if isinstance(value, bool):\n            return value\n        if isinstance(value, str):\n            return value in {'True', 'true', 't', '1', '1.0'}\n        if isinstance(value, int):\n            return value != 0\n        if isinstance(value, float):\n            return value != 0.0\n        return False\n    # Everything else is a date or time\n\n    elif sdml_type == \"datetime\":\n        if type(value) == datetime.date:\n            return datetime.datetime(value.year, value.month, value.day, 0, 0, 0)\n        if isinstance(value, str):\n            try:\n                return datetime.datetime.fromisoformat(value)\n            except Exception:\n                raise InvalidDataException(f\"Can't convert {value} to datetime\")\n        raise InvalidDataException(f\"Can't convert {value} to datetime\")\n\n    elif sdml_type == \"date\":\n        if type(value) in SDML_PYTHON_TYPES[\"datetime\"]:\n            return value.date()\n        if isinstance(value, str):\n            try:\n                return datetime.datetime.fromisoformat(value).date()\n            except Exception:\n                raise InvalidDataException(f\"Can't convert {value} to date\")\n        raise InvalidDataException(f\"Can't convert {value} to date\")\n\n    elif sdml_type == \"timeofday\":\n        if type(value) in SDML_PYTHON_TYPES[\"datetime\"]:\n            return value.time()\n        if isinstance(value, str):\n            try:\n                return datetime.time.fromisoformat(value)\n            except Exception:\n                try:\n                    return datetime.datetime.fromisoformat(value).time()\n                except Exception:\n                    raise InvalidDataException(f\"Can't convert {value} to time\")\n\n        raise InvalidDataException(f\"Couldn't convert {value} to {sdml_type}\")\n\n    raise InvalidDataException(f\"Don't recognize {sdml_type}\")\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.jsonifiable_column","title":"<code>jsonifiable_column(column, column_type)</code>","text":"<p>Return a jsonifiable version of the column of values, using jsonifiable_value to do the conversion.  We actually cheat a little, only calling _jsonifiable_value if column_type is one of SDML_TIME, \"date\", \"datetime\"</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def jsonifiable_column(column, column_type):\n    '''\n    Return a jsonifiable version of the column of values, using jsonifiable_value\n    to do the conversion.  We actually cheat a little, only calling _jsonifiable_value if column_type\n    is one of SDML_TIME, \"date\", \"datetime\"\n    '''\n    if column_type in NON_JSONIFIABLE_TYPES:\n        return [jsonifiable_value(value, column_type) for value in column]\n    else:\n        return column\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.jsonifiable_row","title":"<code>jsonifiable_row(row, column_types)</code>","text":"<p>IReturn the jsonified form of the row, using jsonifiable_value for each element Arguments:     row -- the row to be converted     column_types -- the types of each element of the row Returns     A row of jsonifiable values</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def jsonifiable_row(row, column_types):\n    '''\n    IReturn the jsonified form of the row, using jsonifiable_value for each element\n    Arguments:\n        row -- the row to be converted\n        column_types -- the types of each element of the row\n    Returns\n        A row of jsonifiable values\n    '''\n    return [jsonifiable_value(row[i], column_types[i]) for i in range(len(row))]\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.jsonifiable_rows","title":"<code>jsonifiable_rows(rows, column_types)</code>","text":"<p>Return the jsonifiable form of the list of rows, using jasonifiable_row for each row Arguments:     rows -- the list of rows to be converted     column_types -- the types of each element of the row Returns     A list of rows  of jsonified values</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def jsonifiable_rows(rows, column_types):\n    '''\n    Return the jsonifiable form of the list of rows, using jasonifiable_row for each row\n    Arguments:\n        rows -- the list of rows to be converted\n        column_types -- the types of each element of the row\n    Returns\n        A list of rows  of jsonified values\n    '''\n    return [jsonifiable_row(row, column_types) for row in rows]\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.jsonifiable_value","title":"<code>jsonifiable_value(value, column_type)</code>","text":"<p>Python doesn't jsonify dates, datetimes, or times properly, so convert them to isoformat strings.  Return everything else as is Arguments:     value -- the value to be converted     column_type -- the SDTP type of the value Returns     A jsonifiable form of the value</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def jsonifiable_value(value, column_type):\n    '''\n    Python doesn't jsonify dates, datetimes, or times properly, so\n    convert them to isoformat strings.  Return everything else as is\n    Arguments:\n        value -- the value to be converted\n        column_type -- the SDTP type of the value\n    Returns\n        A jsonifiable form of the value\n    '''\n    if column_type in NON_JSONIFIABLE_TYPES:\n        return value.isoformat()\n    else:\n        return value\n</code></pre>"},{"location":"api/#sdtp.sdtp_utils.resolve_auth_method","title":"<code>resolve_auth_method(method)</code>","text":"<p>Resolve an AuthMethod dict to a credential string. Returns None if the method can't be satisfied (env var/file missing, etc.).</p> Source code in <code>src/sdtp/sdtp_utils.py</code> <pre><code>def resolve_auth_method(method: AuthMethod) -&gt; Optional[str]:\n    \"\"\"\n    Resolve an AuthMethod dict to a credential string.\n    Returns None if the method can't be satisfied (env var/file missing, etc.).\n    \"\"\"\n    if \"env\" in method:\n        return os.environ.get(method[\"env\"])\n    elif \"path\" in method:\n        try:\n            with open(os.path.expanduser(method[\"path\"]), \"r\") as f:\n                return f.read().strip()\n        except Exception:\n            return None\n    elif \"value\" in method:\n        return method[\"value\"]\n    return None\n</code></pre>"}]}